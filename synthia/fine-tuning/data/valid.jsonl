{"messages":[{"role":"user","content":"Show me idiomatic Go context usage"},{"role":"assistant","content":"Idiomatic context usage:\n\n```go\nimport \"context\"\n\n// ✅ Accept context as first parameter\nfunc FetchUser(ctx context.Context, id int) (*User, error) {\n    // Check if context is cancelled\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n    \n    // Use context for cancellation and timeouts\n    req, _ := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    resp, err := client.Do(req)\n    // ...\n}\n\n// ✅ Create context with timeout\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()  // Always call cancel\n\nuser, err := FetchUser(ctx, 123)\n\n// ✅ Pass context through call chain\nfunc HandleRequest(ctx context.Context) {\n    user := GetUser(ctx, id)  // Context flows down\n    posts := GetPosts(ctx, user.ID)\n}\n\n// ✅ Add values to context (use sparingly)\ntype key string\nconst userKey key = \"user\"\n\nctx = context.WithValue(ctx, userKey, user)\nuser := ctx.Value(userKey).(*User)\n```\n\nIdiomatic principles:\n1. Context is always first parameter\n2. Call cancel() in defer after creating context\n3. Check ctx.Done() for cancellation\n4. Pass context through call chains\n5. Don't store contexts in structs\n\nContext enables cancellation and timeouts."}]}
{"messages":[{"role":"user","content":"How do I use Go's make and new idiomatically?"},{"role":"assistant","content":"Idiomatic make vs new:\n\n```go\n// ✅ Use make for slices, maps, channels\nslice := make([]int, 0, 10)     // len=0, cap=10\nslice := make([]int, 5)         // len=5, cap=5\nmap := make(map[string]int)\nchan := make(chan int, 10)      // Buffered channel\n\n// ✅ Use new for pointers to zero values (rare)\nptr := new(int)  // *int pointing to 0\n\n// ✅ Prefer struct literals over new\n// ❌ Less idiomatic\nuser := new(User)\nuser.Name = \"Alice\"\n\n// ✅ More idiomatic\nuser := &User{\n    Name: \"Alice\",\n    Age:  30,\n}\n\n// ✅ Slice literal vs make\nslice := []int{1, 2, 3}         // Literal (when values known)\nslice := make([]int, 0, 100)    // make (when capacity matters)\n\n// ✅ Map literal vs make\nmap := map[string]int{\"a\": 1}   // Literal\nmap := make(map[string]int)     // Empty map\n```\n\nIdiomatic rules:\n1. `make` for slices, maps, channels (initializes)\n2. `new` returns pointer to zero value (rarely used)\n3. Prefer struct literals: `&User{...}` over `new(User)`\n4. Literals for known values, make for capacity\n\nMake allocates and initializes."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Go table-driven tests"},{"role":"assistant","content":"Idiomatic table-driven tests:\n\n```go\nimport \"testing\"\n\n// ✅ Table-driven test pattern\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name string\n        a    int\n        b    int\n        want int\n    }{\n        {name: \"positive numbers\", a: 2, b: 3, want: 5},\n        {name: \"negative numbers\", a: -1, b: -2, want: -3},\n        {name: \"zero\", a: 0, b: 0, want: 0},\n        {name: \"mixed\", a: -1, b: 1, want: 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := Add(tt.a, tt.b)\n            if got != tt.want {\n                t.Errorf(\"Add(%d, %d) = %d, want %d\", tt.a, tt.b, got, tt.want)\n            }\n        })\n    }\n}\n\n// ✅ Test helper with t.Helper()\nfunc assertEqual(t *testing.T, got, want int) {\n    t.Helper()  // Marks this as helper, better error lines\n    if got != want {\n        t.Errorf(\"got %d, want %d\", got, want)\n    }\n}\n```\n\nIdiomatic principles:\n1. Table-driven tests reduce duplication\n2. Use `t.Run()` for subtests\n3. Name test cases descriptively\n4. `t.Helper()` for test helper functions\n\nTable-driven tests are the Go way."}]}
{"messages":[{"role":"user","content":"What's the idiomatic way to use Go's init functions?"},{"role":"assistant","content":"Idiomatic init function usage:\n\n```go\n// ✅ init runs before main\nvar config Config\n\nfunc init() {\n    // Initialize package-level variables\n    config = loadConfig()\n}\n\n// ✅ Multiple init functions (run in order)\nfunc init() {\n    validateEnvironment()\n}\n\nfunc init() {\n    setupDatabase()\n}\n\n// ❌ Avoid heavy initialization in init\nfunc init() {\n    // ❌ Don't make network calls\n    // ❌ Don't open files\n    // ❌ Don't do expensive computation\n}\n\n// ✅ Prefer explicit initialization\ntype Server struct {\n    db *Database\n}\n\nfunc NewServer() (*Server, error) {\n    db, err := openDatabase()  // ✅ Explicit, can return error\n    if err != nil {\n        return nil, err\n    }\n    return &Server{db: db}, nil\n}\n```\n\nIdiomatic principles:\n1. Use init sparingly (hard to test)\n2. Good for: registering drivers, validating constants\n3. Bad for: I/O, expensive operations\n4. Prefer explicit initialization (NewXxx functions)\n5. init functions can't return errors\n\nInit is powerful but should be used sparingly."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Rust module organization"},{"role":"assistant","content":"Idiomatic Rust module structure:\n\n```rust\n// ✅ src/lib.rs - Library root\npub mod parser;  // Defined in parser.rs\npub mod lexer;   // Defined in lexer.rs\nmod utils;       // Private module\n\n// Re-export for convenience\npub use parser::Parser;\npub use lexer::Lexer;\n\n// ✅ src/parser.rs\nuse crate::lexer::Token;\n\npub struct Parser {\n    tokens: Vec<Token>,\n}\n\nimpl Parser {\n    pub fn new(tokens: Vec<Token>) -> Self {\n        Self { tokens }\n    }\n}\n\n// ✅ src/parser/mod.rs for submodules\npub mod ast;\npub mod error;\n\nuse ast::Node;\n\n// ✅ src/main.rs - Binary\nuse my_lib::{Parser, Lexer};  // Use lib.rs exports\n\nfn main() {\n    let lexer = Lexer::new(input);\n    let parser = Parser::new(lexer.tokens());\n}\n```\n\nIdiomatic principles:\n1. `lib.rs` for libraries, `main.rs` for binaries\n2. `pub` makes items public\n3. Re-export common items at crate root\n4. `mod.rs` for modules with submodules\n5. `use crate::` for absolute paths\n\nModules enable encapsulation and organization."}]}
{"messages":[{"role":"user","content":"How do I use cfg attributes idiomatically in Rust?"},{"role":"assistant","content":"Idiomatic cfg attribute usage:\n\n```rust\n// ✅ Conditional compilation by OS\n#[cfg(target_os = \"windows\")]\nfn get_config_path() -> PathBuf {\n    PathBuf::from(\"C:\\\\config.toml\")\n}\n\n#[cfg(target_os = \"linux\")]\nfn get_config_path() -> PathBuf {\n    PathBuf::from(\"/etc/config.toml\")\n}\n\n// ✅ Debug vs release\n#[cfg(debug_assertions)]\nfn log_debug(msg: &str) {\n    println!(\"DEBUG: {}\", msg);\n}\n\n#[cfg(not(debug_assertions))]\nfn log_debug(_msg: &str) {\n    // No-op in release\n}\n\n// ✅ Feature flags\n#[cfg(feature = \"json\")]\nuse serde_json;\n\n#[cfg(feature = \"json\")]\npub fn parse_json(s: &str) -> Result<Value> {\n    serde_json::from_str(s)\n}\n\n// ✅ Test-only code\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_parse() {\n        assert_eq!(parse(\"hello\"), Ok(\"hello\"));\n    }\n}\n```\n\nIdiomatic patterns:\n1. `cfg` for platform-specific code\n2. `debug_assertions` for debug-only code\n3. Feature flags for optional dependencies\n4. `cfg(test)` for test modules\n\nConditional compilation keeps binaries small."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Rust macro usage"},{"role":"assistant","content":"Idiomatic macro usage:\n\n```rust\n// ✅ Use built-in macros\nlet v = vec![1, 2, 3];  // vec! macro\nprintln!(\"Value: {}\", x);  // println! macro\npanic!(\"Something went wrong!\");  // panic! macro\n\n// ✅ Derive macros (most common)\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\nstruct User {\n    name: String,\n    age: u32,\n}\n\n// ✅ Simple declarative macro\nmacro_rules! hashmap {\n    ($($key:expr => $val:expr),* $(,)?) => {{\n        let mut map = HashMap::new();\n        $(\n            map.insert($key, $val);\n        )*\n        map\n    }};\n}\n\nlet map = hashmap! {\n    \"a\" => 1,\n    \"b\" => 2,\n};\n\n// ✅ Use macros for repetitive code\nmacro_rules! impl_from {\n    ($from:ty => $to:ty) => {\n        impl From<$from> for $to {\n            fn from(val: $from) -> Self {\n                Self(val)\n            }\n        }\n    };\n}\n```\n\nIdiomatic principles:\n1. Prefer derive macros over manual impls\n2. Use macros for repetitive patterns\n3. Don't overuse - functions are clearer\n4. Procedural macros for complex codegen\n\nMacros reduce boilerplate but can hurt readability."}]}
{"messages":[{"role":"user","content":"What's the idiomatic way to handle AsRef and AsMut in Rust?"},{"role":"assistant","content":"Idiomatic AsRef/AsMut usage:\n\n```rust\nuse std::path::Path;\n\n// ✅ Accept AsRef for flexible APIs\nfn open_file(path: impl AsRef<Path>) -> Result<File> {\n    let path = path.as_ref();\n    File::open(path)\n}\n\n// Now accepts both:\nopen_file(\"/tmp/file.txt\");      // &str\nopen_file(String::from(\"/tmp/file.txt\"));  // String\nopen_file(PathBuf::from(\"/tmp/file.txt\")); // PathBuf\n\n// ✅ AsRef<str> for string-like types\nfn print_message(msg: impl AsRef<str>) {\n    println!(\"{}\", msg.as_ref());\n}\n\nprint_message(\"hello\");           // &str\nprint_message(String::from(\"hello\"));  // String\n\n// ✅ AsMut for mutable references\nfn increment_all(data: impl AsMut<[i32]>) {\n    let slice = data.as_mut();\n    for x in slice {\n        *x += 1;\n    }\n}\n\nlet mut vec = vec![1, 2, 3];\nincrement_all(&mut vec);\n```\n\nIdiomatic principles:\n1. Use `impl AsRef<T>` for flexible parameters\n2. Accepts multiple types without overhead\n3. `AsRef<Path>` for file paths\n4. `AsRef<str>` for string parameters\n5. `AsMut<T>` for mutable conversions\n\nAsRef makes APIs ergonomic without sacrificing performance."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Rust testing patterns"},{"role":"assistant","content":"Idiomatic Rust testing:\n\n```rust\n// ✅ Unit tests in same file\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_addition() {\n        assert_eq!(add(2, 3), 5);\n    }\n\n    #[test]\n    #[should_panic(expected = \"division by zero\")]\n    fn test_divide_by_zero() {\n        divide(10, 0);\n    }\n\n    #[test]\n    fn test_result() -> Result<(), String> {\n        let value = parse(\"42\")?;\n        assert_eq!(value, 42);\n        Ok(())\n    }\n}\n\n// ✅ Integration tests in tests/\n// tests/integration_test.rs\nuse my_crate::*;\n\n#[test]\nfn test_end_to_end() {\n    let result = process_data(input);\n    assert!(result.is_ok());\n}\n\n// ✅ Doc tests in comments\n/// Adds two numbers.\n///\n/// # Examples\n///\n/// ```\n/// use my_crate::add;\n/// assert_eq!(add(2, 3), 5);\n/// ```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n// ✅ Test helpers\n#[cfg(test)]\nfn create_test_user() -> User {\n    User {\n        name: \"Test\".to_string(),\n        age: 25,\n    }\n}\n```\n\nIdiomatic principles:\n1. Unit tests in `#[cfg(test)] mod tests`\n2. Integration tests in `tests/` directory\n3. Doc tests in documentation comments\n4. `assert_eq!`, `assert!`, `#[should_panic]`\n5. Test helpers with `#[cfg(test)]`"}]}
{"messages":[{"role":"user","content":"How do I use Rust's smart pointers idiomatically?"},{"role":"assistant","content":"Idiomatic smart pointer usage:\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::sync::Arc;\n\n// ✅ Box for heap allocation\nlet boxed = Box::new(5);\nlet large_data = Box::new([0; 1_000_000]);  // Too large for stack\n\n// ✅ Rc for shared ownership (single-threaded)\nlet shared = Rc::new(vec![1, 2, 3]);\nlet clone1 = Rc::clone(&shared);  // ✅ Use Rc::clone, not .clone()\nlet clone2 = Rc::clone(&shared);\n\n// ✅ Arc for shared ownership (multi-threaded)\nlet arc = Arc::new(vec![1, 2, 3]);\nlet arc_clone = Arc::clone(&arc);\nstd::thread::spawn(move || {\n    println!(\"{:?}\", arc_clone);\n});\n\n// ✅ RefCell for interior mutability\nlet data = RefCell::new(5);\n*data.borrow_mut() += 1;  // Mutable borrow at runtime\nassert_eq!(*data.borrow(), 6);\n\n// ✅ Rc<RefCell<T>> for shared mutable data\nlet shared_mut = Rc::new(RefCell::new(vec![1, 2]));\nshared_mut.borrow_mut().push(3);\n```\n\nIdiomatic principles:\n1. `Box<T>` for heap allocation and trait objects\n2. `Rc<T>` for shared ownership (single-thread)\n3. `Arc<T>` for shared ownership (multi-thread)\n4. `RefCell<T>` for interior mutability\n5. Use `Rc::clone(&x)` not `x.clone()`\n\nSmart pointers enable patterns beyond ownership rules."}]}
{"messages":[{"role":"user","content":"Show me idiomatic TypeScript conditional types"},{"role":"assistant","content":"Idiomatic conditional types:\n\n```typescript\n// ✅ Basic conditional type\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;  // true\ntype B = IsString<number>;  // false\n\n// ✅ Extract function return type\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction getUser() { return { name: \"Alice\" }; }\ntype User = ReturnType<typeof getUser>;  // { name: string }\n\n// ✅ Exclude types from union\ntype Exclude<T, U> = T extends U ? never : T;\n\ntype A = Exclude<'a' | 'b' | 'c', 'a'>;  // 'b' | 'c'\n\n// ✅ NonNullable helper\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype A = NonNullable<string | null>;  // string\n\n// ✅ Distributive conditional types\ntype ToArray<T> = T extends any ? T[] : never;\ntype A = ToArray<string | number>;  // string[] | number[]\n```\n\nIdiomatic patterns:\n1. `T extends U ? X : Y` for conditional logic\n2. `infer` to extract types\n3. Distributive over unions\n4. Built-in utilities use conditional types\n\nConditional types enable advanced type transformations."}]}
{"messages":[{"role":"user","content":"What's the idiomatic way to use template literal types in TypeScript?"},{"role":"assistant","content":"Idiomatic template literal types:\n\n```typescript\n// ✅ Basic template literal type\ntype Greeting = `Hello, ${string}!`;\n\nconst msg1: Greeting = \"Hello, World!\";  // ✅ Valid\nconst msg2: Greeting = \"Hi there\";       // ❌ Error\n\n// ✅ Union of template literals\ntype EventName = 'click' | 'focus' | 'blur';\ntype EventHandler = `on${Capitalize<EventName>}`;\n// 'onClick' | 'onFocus' | 'onBlur'\n\n// ✅ CSS properties\ntype CSSProperty = `margin-${'top' | 'right' | 'bottom' | 'left'}`;\n// 'margin-top' | 'margin-right' | 'margin-bottom' | 'margin-left'\n\n// ✅ Type-safe routes\ntype Route = '/users' | '/posts';\ntype DetailRoute = `${Route}/${string}`;\n\nconst route: DetailRoute = '/users/123';  // ✅ Valid\n\n// ✅ Intrinsic string manipulation\ntype Uppercased = Uppercase<'hello'>;     // 'HELLO'\ntype Lowercased = Lowercase<'HELLO'>;     // 'hello'\ntype Capitalized = Capitalize<'hello'>;   // 'Hello'\ntype Uncapitalized = Uncapitalize<'Hello'>;  // 'hello'\n```\n\nIdiomatic patterns:\n1. Template literals for string patterns\n2. Combine with unions for permutations\n3. Built-in string manipulation types\n4. Type-safe string constants\n\nTemplate literal types make string types precise."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Python __slots__ usage"},{"role":"assistant","content":"Idiomatic __slots__ usage:\n\n```python\n# ✅ Use __slots__ for memory optimization\nclass Point:\n    __slots__ = ['x', 'y']  # Only these attributes allowed\n    \n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# Benefits:\n# 1. Reduces memory (no __dict__)\n# 2. Faster attribute access\n# 3. Prevents typos (can't add arbitrary attributes)\n\np = Point(1, 2)\nprint(p.x)  # ✅ Works\np.z = 3     # ❌ AttributeError: no attribute 'z'\n\n# ✅ __slots__ with inheritance\nclass Point3D(Point):\n    __slots__ = ['z']  # Extends parent's slots\n    \n    def __init__(self, x, y, z):\n        super().__init__(x, y)\n        self.z = z\n\n# ❌ Don't use __slots__ everywhere\n# Only use when:\n# - Creating many instances (memory matters)\n# - Class is stable (attributes won't change)\n```\n\nIdiomatic principles:\n1. Use `__slots__` for memory-intensive classes\n2. List all instance attributes\n3. Prevents dynamic attribute assignment\n4. Faster attribute access\n5. Works with inheritance\n\nSlots optimize memory at the cost of flexibility."}]}
{"messages":[{"role":"user","content":"How do I use Python's namedtuple idiomatically?"},{"role":"assistant","content":"Idiomatic namedtuple usage:\n\n```python\nfrom collections import namedtuple\n\n# ✅ Create immutable data structures\nPoint = namedtuple('Point', ['x', 'y'])\n\np = Point(1, 2)\nprint(p.x, p.y)  # Named access\nprint(p[0], p[1])  # Index access\n\n# ✅ With defaults (Python 3.7+)\nPoint = namedtuple('Point', ['x', 'y'], defaults=[0, 0])\np = Point()  # Point(x=0, y=0)\n\n# ✅ Use _make for creating from iterables\ndata = [3, 4]\np = Point._make(data)\n\n# ✅ Use _asdict for conversion to dict\nprint(p._asdict())  # {'x': 3, 'y': 4}\n\n# ✅ Use _replace for creating modified copies\np2 = p._replace(x=10)  # Point(x=10, y=4)\n\n# ❌ Consider dataclass for more features\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)  # Immutable like namedtuple\nclass Point:\n    x: int = 0\n    y: int = 0\n```\n\nIdiomatic principles:\n1. Namedtuples for simple immutable data\n2. Lighter than classes\n3. `_make`, `_asdict`, `_replace` are useful\n4. Consider dataclass for methods/validation\n\nNamedtuples are lightweight immutable containers."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Python itertools patterns"},{"role":"assistant","content":"Idiomatic itertools usage:\n\n```python\nfrom itertools import (\n    chain, islice, cycle, repeat,\n    groupby, combinations, permutations,\n    zip_longest, accumulate, product\n)\n\n# ✅ chain - flatten iterables\nresult = chain([1, 2], [3, 4], [5, 6])  # 1, 2, 3, 4, 5, 6\n\n# ✅ islice - slice iterator\nfirst_10 = islice(infinite_sequence, 10)\n\n# ✅ cycle - infinite repeating\ncolors = cycle(['red', 'green', 'blue'])  # Infinite\n\n# ✅ groupby - group consecutive elements\ndata = [('A', 1), ('A', 2), ('B', 1), ('B', 2)]\nfor key, group in groupby(data, key=lambda x: x[0]):\n    print(f\"{key}: {list(group)}\")\n# A: [('A', 1), ('A', 2)]\n# B: [('B', 1), ('B', 2)]\n\n# ✅ combinations - all combinations\nlist(combinations([1, 2, 3], 2))  # [(1,2), (1,3), (2,3)]\n\n# ✅ product - cartesian product\nlist(product([1, 2], ['a', 'b']))  # [(1,'a'), (1,'b'), (2,'a'), (2,'b')]\n\n# ✅ accumulate - running totals\nlist(accumulate([1, 2, 3, 4]))  # [1, 3, 6, 10]\n```\n\nIdiomatic patterns:\n1. Itertools for efficient iteration\n2. Lazy evaluation - no intermediate lists\n3. Composable iterator operations\n4. Memory efficient\n\nItertools are Python's functional programming toolkit."}]}
{"messages":[{"role":"user","content":"What's the idiomatic way to use Python's functools?"},{"role":"assistant","content":"Idiomatic functools usage:\n\n```python\nfrom functools import (\n    lru_cache, wraps, partial,\n    reduce, cached_property\n)\n\n# ✅ lru_cache for memoization\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# ✅ wraps for preserving metadata\ndef my_decorator(func):\n    @wraps(func)  # Preserves func.__name__, __doc__, etc.\n    def wrapper(*args, **kwargs):\n        print(\"Before\")\n        result = func(*args, **kwargs)\n        print(\"After\")\n        return result\n    return wrapper\n\n# ✅ partial for partial application\nfrom functools import partial\n\ndef power(base, exponent):\n    return base ** exponent\n\nsquare = partial(power, exponent=2)\ncube = partial(power, exponent=3)\n\nprint(square(5))  # 25\nprint(cube(5))    # 125\n\n# ✅ cached_property for expensive properties\nclass DataLoader:\n    @cached_property\n    def data(self):\n        return load_expensive_data()  # Cached after first access\n\n# ✅ reduce for aggregation\nnumbers = [1, 2, 3, 4]\ntotal = reduce(lambda x, y: x + y, numbers)  # 10\n```\n\nIdiomatic patterns:\n1. `lru_cache` for expensive pure functions\n2. `wraps` in all decorators\n3. `partial` for function specialization\n4. `cached_property` for lazy expensive attributes\n\nFunctools make functional programming natural."}]}
{"messages":[{"role":"user","content":"Show me idiomatic Go JSON handling"},{"role":"assistant","content":"Idiomatic JSON handling in Go:\n\n```go\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\n// ✅ Struct tags for JSON marshaling\ntype User struct {\n    ID       int    `json:\"id\"`\n    Name     string `json:\"name\"`\n    Email    string `json:\"email,omitempty\"`  // Omit if empty\n    Password string `json:\"-\"`                // Never marshal\n    Age      int    `json:\"age,string\"`       // Marshal as string\n}\n\n// ✅ Marshaling\nuser := User{ID: 1, Name: \"Alice\", Email: \"alice@example.com\"}\ndata, err := json.Marshal(user)\nif err != nil {\n    return err\n}\n\n// ✅ Unmarshaling\nvar user User\nif err := json.Unmarshal(data, &user); err != nil {\n    return err\n}\n\n// ✅ Custom JSON encoding\nfunc (u User) MarshalJSON() ([]byte, error) {\n    type Alias User  // Avoid recursion\n    return json.Marshal(&struct {\n        *Alias\n        CreatedAt string `json:\"created_at\"`\n    }{\n        Alias:     (*Alias)(&u),\n        CreatedAt: time.Now().Format(time.RFC3339),\n    })\n}\n\n// ✅ JSON streaming for large data\nenc := json.NewEncoder(writer)\nif err := enc.Encode(user); err != nil {\n    return err\n}\n```\n\nIdiomatic patterns:\n1. Struct tags control JSON behavior\n2. `omitempty` skips zero values\n3. `\"-\"` excludes fields\n4. Custom MarshalJSON for complex logic\n5. Streaming for large payloads\n\nJSON encoding is type-safe in Go."}]}
{"messages":[{"role":"user","content":"Write a Rust function using the newtype pattern"},{"role":"assistant","content":"Idiomatic newtype pattern in Rust:\n\n```rust\n// ✅ Newtype for type safety\nstruct UserId(u32);\nstruct ProductId(u32);\n\nimpl UserId {\n    fn new(id: u32) -> Self {\n        UserId(id)\n    }\n    \n    fn value(&self) -> u32 {\n        self.0\n    }\n}\n\nfn fetch_user(id: UserId) -> User {\n    // Can't accidentally pass ProductId\n    database.get_user(id.value())\n}\n\n// ✅ Prevents mixing up similar types\nlet user_id = UserId::new(42);\nlet product_id = ProductId::new(42);\nfetch_user(user_id); // ✅ Works\n// fetch_user(product_id); // ❌ Compile error!\n```\n\nBenefits:\n1. Zero-cost abstraction (no runtime overhead)\n2. Type safety (prevents mixing similar types)\n3. Clear intent (UserId vs raw u32)\n4. Can add methods specific to the type"}]}
{"messages":[{"role":"user","content":"Show Rust interior mutability with RefCell"},{"role":"assistant","content":"Interior mutability pattern:\n\n```rust\nuse std::cell::RefCell;\n\n// ✅ Mutate through immutable reference\nstruct Cache {\n    data: RefCell<HashMap<String, String>>,\n}\n\nimpl Cache {\n    fn get(&self, key: &str) -> Option<String> {\n        self.data.borrow().get(key).cloned()\n    }\n    \n    fn set(&self, key: String, value: String) {\n        self.data.borrow_mut().insert(key, value);\n    }\n}\n\n// ✅ Use when you need runtime borrow checking\nlet cache = Cache { data: RefCell::new(HashMap::new()) };\ncache.set(\"key\".to_string(), \"value\".to_string());\n\n// ❌ Will panic at runtime if rules violated\n// let r1 = cache.data.borrow();\n// let r2 = cache.data.borrow_mut(); // Panic!\n```\n\nWhen to use:\n1. Need mutation through shared reference\n2. Compile-time borrow checker too restrictive\n3. Runtime checks acceptable\n4. Single-threaded (use Mutex for multi-threaded)"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust From and Into trait implementations"},{"role":"assistant","content":"Idiomatic From/Into conversions:\n\n```rust\n// ✅ Implement From for conversions\nstruct Kilometers(f64);\nstruct Miles(f64);\n\nimpl From<Miles> for Kilometers {\n    fn from(miles: Miles) -> Self {\n        Kilometers(miles.0 * 1.60934)\n    }\n}\n\n// Into is automatically implemented\nlet miles = Miles(10.0);\nlet km: Kilometers = miles.into();\nlet km2 = Kilometers::from(Miles(5.0));\n\n// ✅ From for error conversion\nimpl From<io::Error> for MyError {\n    fn from(err: io::Error) -> Self {\n        MyError::Io(err)\n    }\n}\n\n// Now can use ? operator\nfn read_file() -> Result<String, MyError> {\n    let contents = fs::read_to_string(\"file.txt\")?; // Auto converts\n    Ok(contents)\n}\n```\n\nBest practices:\n1. Implement From, get Into for free\n2. Use for infallible conversions\n3. Enables ? operator with errors\n4. Makes APIs ergonomic"}]}
{"messages":[{"role":"user","content":"Show Rust builder pattern with derive_builder"},{"role":"assistant","content":"Builder pattern idioms:\n\n```rust\nuse derive_builder::Builder;\n\n// ✅ Use derive_builder for ergonomic builders\n#[derive(Builder, Debug)]\n#[builder(setter(into))]\nstruct HttpRequest {\n    url: String,\n    #[builder(default)]\n    method: String,\n    #[builder(default)]\n    headers: HashMap<String, String>,\n    #[builder(default)]\n    body: Option<String>,\n}\n\nlet request = HttpRequestBuilder::default()\n    .url(\"https://api.example.com\")\n    .method(\"POST\")\n    .body(Some(\"{\\\"key\\\": \\\"value\\\"}\"))\n    .build()\n    .unwrap();\n\n// ✅ Manual builder for more control\nimpl HttpRequest {\n    fn builder() -> HttpRequestBuilder {\n        HttpRequestBuilder::default()\n    }\n}\n\nlet req = HttpRequest::builder()\n    .url(\"https://example.com\")\n    .build()\n    .unwrap();\n```\n\nBenefits:\n1. Optional fields with defaults\n2. Compile-time field validation\n3. Fluent API\n4. Type-safe construction"}]}
{"messages":[{"role":"user","content":"Write Rust code using Cow for efficient string handling"},{"role":"assistant","content":"Cow (Clone on Write) pattern:\n\n```rust\nuse std::borrow::Cow;\n\n// ✅ Use Cow to avoid unnecessary clones\nfn process_text(input: &str) -> Cow<str> {\n    if input.contains(\"bad\") {\n        Cow::Owned(input.replace(\"bad\", \"good\")) // Only clone when needed\n    } else {\n        Cow::Borrowed(input) // No allocation!\n    }\n}\n\nlet text1 = \"hello world\";\nlet result1 = process_text(text1); // Borrowed, no allocation\n\nlet text2 = \"bad words\";\nlet result2 = process_text(text2); // Owned, allocated\n\n// ✅ Cow in function signatures\nfn display(s: Cow<str>) {\n    println!(\"{}\", s);\n}\n\ndisplay(\"literal\".into()); // Borrowed\ndisplay(String::from(\"owned\").into()); // Owned\n\n// ✅ Cow with to_mut for conditional mutation\nlet mut data: Cow<str> = \"hello\".into();\nif needs_modification {\n    data.to_mut().push_str(\" world\"); // Clones if borrowed\n}\n```\n\nUse Cow when:\n1. Might or might not need to modify\n2. Want to avoid clones when possible\n3. Accept both &str and String ergonomically"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust PhantomData usage"},{"role":"assistant","content":"PhantomData for zero-cost type safety:\n\n```rust\nuse std::marker::PhantomData;\n\n// ✅ Type-state pattern with PhantomData\nstruct Locked;\nstruct Unlocked;\n\nstruct Door<State> {\n    _state: PhantomData<State>,\n}\n\nimpl Door<Locked> {\n    fn new() -> Self {\n        Door { _state: PhantomData }\n    }\n    \n    fn unlock(self) -> Door<Unlocked> {\n        Door { _state: PhantomData }\n    }\n}\n\nimpl Door<Unlocked> {\n    fn open(&self) {\n        println!(\"Opening door\");\n    }\n    \n    fn lock(self) -> Door<Locked> {\n        Door { _state: PhantomData }\n    }\n}\n\n// ✅ Compile-time state enforcement\nlet door = Door::<Locked>::new();\n// door.open(); // ❌ Compile error!\nlet door = door.unlock();\ndoor.open(); // ✅ Works\n```\n\nBenefits:\n1. Zero runtime cost\n2. Compile-time state machine\n3. Impossible to misuse API\n4. Self-documenting code"}]}
{"messages":[{"role":"user","content":"Show Rust async/await with proper error handling"},{"role":"assistant","content":"Idiomatic async Rust patterns:\n\n```rust\nuse tokio;\nuse anyhow::{Result, Context};\n\n// ✅ Use ? with context for errors\nasync fn fetch_user(id: u32) -> Result<User> {\n    let url = format!(\"https://api.example.com/users/{}\", id);\n    \n    let response = reqwest::get(&url)\n        .await\n        .context(\"Failed to send request\")?;\n    \n    let user = response.json::<User>()\n        .await\n        .context(\"Failed to parse user\")?;\n    \n    Ok(user)\n}\n\n// ✅ Concurrent operations with join!\nasync fn fetch_dashboard() -> Result<Dashboard> {\n    let (users, posts, comments) = tokio::try_join!(\n        fetch_users(),\n        fetch_posts(),\n        fetch_comments(),\n    )?;\n    \n    Ok(Dashboard { users, posts, comments })\n}\n\n// ✅ Timeout with tokio::time\nuse tokio::time::{timeout, Duration};\n\nasync fn fetch_with_timeout() -> Result<Data> {\n    timeout(Duration::from_secs(5), fetch_data())\n        .await\n        .context(\"Request timed out\")?\n}\n```\n\nAsync best practices:\n1. Use anyhow/thiserror for errors\n2. try_join! for parallel operations\n3. Add timeouts to external calls\n4. Context for error messages"}]}
{"messages":[{"role":"user","content":"Write Rust code using Arc and Mutex for shared state"},{"role":"assistant","content":"Thread-safe shared state patterns:\n\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\n// ✅ Arc<Mutex<T>> for shared mutable state\nstruct AppState {\n    counter: Arc<Mutex<u32>>,\n}\n\nimpl AppState {\n    fn new() -> Self {\n        Self {\n            counter: Arc::new(Mutex::new(0)),\n        }\n    }\n    \n    fn increment(&self) {\n        let mut count = self.counter.lock().unwrap();\n        *count += 1;\n    } // Lock released here\n}\n\n// ✅ Share across threads\nlet state = AppState::new();\nlet handles: Vec<_> = (0..10)\n    .map(|_| {\n        let state_clone = state.clone();\n        thread::spawn(move || {\n            state_clone.increment();\n        })\n    })\n    .collect();\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n\n// ✅ Use RwLock for read-heavy workloads\nuse std::sync::RwLock;\nlet cache: Arc<RwLock<HashMap<String, String>>> = Arc::new(RwLock::new(HashMap::new()));\n\n// Multiple readers\nlet data = cache.read().unwrap();\n// Single writer\nlet mut data = cache.write().unwrap();\n```\n\nPatterns:\n1. Arc for shared ownership across threads\n2. Mutex for exclusive access\n3. RwLock when reads >> writes\n4. Keep lock scopes small"}]}
{"messages":[{"role":"user","content":"Show Rust const generics usage"},{"role":"assistant","content":"Const generics for compile-time arrays:\n\n```rust\n// ✅ Stack-allocated fixed-size arrays\nstruct Matrix<T, const ROWS: usize, const COLS: usize> {\n    data: [[T; COLS]; ROWS],\n}\n\nimpl<T: Default + Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {\n    fn new() -> Self {\n        Self {\n            data: [[T::default(); COLS]; ROWS],\n        }\n    }\n    \n    fn get(&self, row: usize, col: usize) -> Option<&T> {\n        self.data.get(row)?.get(col)\n    }\n}\n\n// ✅ Type-safe dimensions\nlet mat3x3: Matrix<f64, 3, 3> = Matrix::new();\nlet mat4x4: Matrix<f64, 4, 4> = Matrix::new();\n\n// ✅ Generic array functions\nfn sum_array<const N: usize>(arr: [i32; N]) -> i32 {\n    arr.iter().sum()\n}\n\nlet total = sum_array([1, 2, 3, 4, 5]); // Works for any size\n```\n\nBenefits:\n1. Compile-time size checking\n2. No heap allocations\n3. Zero runtime cost\n4. Type-safe dimensionality"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust macro_rules! for code generation"},{"role":"assistant","content":"Declarative macros best practices:\n\n```rust\n// ✅ Simple repetition macro\nmacro_rules! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$($x.to_string()),*]\n    };\n}\n\nlet strings = vec_of_strings![\"hello\", \"world\"];\n\n// ✅ Macro for enum with From implementations\nmacro_rules! define_error {\n    ($name:ident { $($variant:ident($inner:ty)),* }) => {\n        #[derive(Debug)]\n        enum $name {\n            $($variant($inner)),*\n        }\n        \n        $(\n            impl From<$inner> for $name {\n                fn from(err: $inner) -> Self {\n                    $name::$variant(err)\n                }\n            }\n        )*\n    };\n}\n\ndefine_error!(MyError {\n    Io(std::io::Error),\n    Parse(std::num::ParseIntError)\n});\n\n// ✅ Hash map literal macro\nmacro_rules! hashmap {\n    ($($key:expr => $val:expr),* $(,)?) => {{\n        let mut map = HashMap::new();\n        $(map.insert($key, $val);)*\n        map\n    }};\n}\n\nlet map = hashmap! {\n    \"key1\" => \"value1\",\n    \"key2\" => \"value2\",\n};\n```\n\nWhen to use macros:\n1. Reduce boilerplate\n2. Domain-specific syntax\n3. Compile-time code generation\n4. When functions can't express pattern"}]}
{"messages":[{"role":"user","content":"Show Rust Drop trait for RAII"},{"role":"assistant","content":"RAII with Drop trait:\n\n```rust\n// ✅ Custom Drop for resource cleanup\nstruct FileHandle {\n    path: String,\n    fd: i32,\n}\n\nimpl Drop for FileHandle {\n    fn drop(&mut self) {\n        println!(\"Closing file: {}\", self.path);\n        // Cleanup happens automatically\n        unsafe { libc::close(self.fd); }\n    }\n}\n\n// ✅ Drop guard for scoped actions\nstruct TimerGuard {\n    name: String,\n    start: Instant,\n}\n\nimpl Drop for TimerGuard {\n    fn drop(&mut self) {\n        let elapsed = self.start.elapsed();\n        println!(\"{} took {:?}\", self.name, elapsed);\n    }\n}\n\nfn expensive_operation() {\n    let _timer = TimerGuard {\n        name: \"expensive_operation\".to_string(),\n        start: Instant::now(),\n    }; // Automatically logs when function exits\n    \n    // ... work ...\n} // Drop called here\n\n// ✅ MutexGuard uses Drop to release lock\nlet data = mutex.lock().unwrap();\n// ... use data ...\n// Lock automatically released when data goes out of scope\n```\n\nRAII principles:\n1. Acquire in constructor\n2. Release in Drop\n3. Automatic cleanup\n4. Exception-safe"}]}
{"messages":[{"role":"user","content":"Write Rust code with custom iterators"},{"role":"assistant","content":"Custom iterator implementation:\n\n```rust\n// ✅ Implement Iterator trait\nstruct Fibonacci {\n    curr: u64,\n    next: u64,\n}\n\nimpl Fibonacci {\n    fn new() -> Self {\n        Fibonacci { curr: 0, next: 1 }\n    }\n}\n\nimpl Iterator for Fibonacci {\n    type Item = u64;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        let current = self.curr;\n        self.curr = self.next;\n        self.next = current + self.next;\n        Some(current)\n    }\n}\n\n// ✅ Use with iterator combinators\nlet fib: Vec<_> = Fibonacci::new()\n    .take(10)\n    .collect();\n\n// ✅ Custom collection iterator\nstruct Grid<T> {\n    data: Vec<Vec<T>>,\n}\n\nimpl<T: Clone> Grid<T> {\n    fn iter(&self) -> GridIter<T> {\n        GridIter {\n            grid: self,\n            row: 0,\n            col: 0,\n        }\n    }\n}\n\nstruct GridIter<'a, T> {\n    grid: &'a Grid<T>,\n    row: usize,\n    col: usize,\n}\n\nimpl<'a, T: Clone> Iterator for GridIter<'a, T> {\n    type Item = &'a T;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        // Implementation details...\n        None\n    }\n}\n```\n\nIterator benefits:\n1. Lazy evaluation\n2. Composable\n3. Zero-cost abstraction\n4. Idiomatic Rust"}]}
{"messages":[{"role":"user","content":"Show Rust unsafe code best practices"},{"role":"assistant","content":"Safe unsafe code patterns:\n\n```rust\n// ✅ Minimize unsafe blocks\nfn read_ptr<T>(ptr: *const T) -> Option<T> \nwhere\n    T: Copy,\n{\n    if ptr.is_null() {\n        return None;\n    }\n    \n    Some(unsafe { *ptr }) // Only unsafe operation\n}\n\n// ✅ Safe abstraction over unsafe code\npub struct RawBuffer {\n    ptr: *mut u8,\n    len: usize,\n    cap: usize,\n}\n\nimpl RawBuffer {\n    pub fn new(capacity: usize) -> Self {\n        let layout = Layout::array::<u8>(capacity).unwrap();\n        let ptr = unsafe { alloc(layout) };\n        \n        Self {\n            ptr,\n            len: 0,\n            cap: capacity,\n        }\n    }\n    \n    // ✅ Safe public interface\n    pub fn push(&mut self, value: u8) {\n        assert!(self.len < self.cap);\n        unsafe {\n            self.ptr.add(self.len).write(value);\n        }\n        self.len += 1;\n    }\n}\n\nimpl Drop for RawBuffer {\n    fn drop(&mut self) {\n        unsafe {\n            let layout = Layout::array::<u8>(self.cap).unwrap();\n            dealloc(self.ptr, layout);\n        }\n    }\n}\n\n// ✅ Document safety invariants\n/// # Safety\n/// Caller must ensure ptr is valid and aligned\nunsafe fn read_aligned<T>(ptr: *const T) -> T {\n    ptr.read()\n}\n```\n\nUnsafe guidelines:\n1. Minimize unsafe blocks\n2. Provide safe public API\n3. Document safety requirements\n4. Maintain invariants"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust trait objects and dynamic dispatch"},{"role":"assistant","content":"Dynamic dispatch with trait objects:\n\n```rust\n// ✅ Use dyn for trait objects\ntrait Drawable {\n    fn draw(&self);\n}\n\nstruct Circle { radius: f64 }\nstruct Rectangle { width: f64, height: f64 }\n\nimpl Drawable for Circle {\n    fn draw(&self) {\n        println!(\"Drawing circle: {}\", self.radius);\n    }\n}\n\nimpl Drawable for Rectangle {\n    fn draw(&self) {\n        println!(\"Drawing rectangle: {}x{}\", self.width, self.height);\n    }\n}\n\n// ✅ Store heterogeneous types\nlet shapes: Vec<Box<dyn Drawable>> = vec![\n    Box::new(Circle { radius: 5.0 }),\n    Box::new(Rectangle { width: 10.0, height: 20.0 }),\n];\n\nfor shape in &shapes {\n    shape.draw(); // Dynamic dispatch\n}\n\n// ✅ Use &dyn when you don't need ownership\nfn render(drawable: &dyn Drawable) {\n    drawable.draw();\n}\n\n// ✅ Object-safe traits only\ntrait NotObjectSafe {\n    fn generic<T>(&self, x: T); // ❌ Not object-safe\n}\n```\n\nTrait object rules:\n1. Must be object-safe (no generics, no Self return)\n2. Runtime dispatch (slight overhead)\n3. Use when types unknown at compile time\n4. Prefer generics for known types"}]}
{"messages":[{"role":"user","content":"Show Rust workspace organization"},{"role":"assistant","content":"Workspace best practices:\n\n```toml\n# ✅ Root Cargo.toml\n[workspace]\nmembers = [\n    \"core\",\n    \"api\",\n    \"cli\",\n]\nresolver = \"2\"\n\n[workspace.package]\nversion = \"0.1.0\"\nauthors = [\"Your Name\"]\nedition = \"2021\"\n\n[workspace.dependencies]\ntokio = { version = \"1.0\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\n\n# ✅ core/Cargo.toml\n[package]\nname = \"myapp-core\"\nversion.workspace = true\nedition.workspace = true\n\n[dependencies]\ntokio.workspace = true\nserde.workspace = true\n\n# ✅ cli/Cargo.toml\n[package]\nname = \"myapp-cli\"\nversion.workspace = true\nedition.workspace = true\n\n[dependencies]\nmyapp-core = { path = \"../core\" }\ntokio.workspace = true\nclap = \"4.0\"\n```\n\nWorkspace benefits:\n1. Shared dependencies (single lock file)\n2. Unified version management\n3. Cross-package refactoring\n4. Single target/ directory"}]}
{"messages":[{"role":"user","content":"Write TypeScript using discriminated unions properly"},{"role":"assistant","content":"Discriminated unions for type safety:\n\n```typescript\n// ✅ Discriminated union with type guards\ntype ApiResponse<T> =\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\nfunction handleResponse<T>(response: ApiResponse<T>) {\n  switch (response.status) {\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return response.data; // ✅ TypeScript knows data exists\n    case 'error':\n      return response.error; // ✅ TypeScript knows error exists\n  }\n}\n\n// ✅ Complex discriminated unions\ntype Shape =\n  | { kind: 'circle'; radius: number }\n  | { kind: 'rectangle'; width: number; height: number }\n  | { kind: 'triangle'; base: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'rectangle':\n      return shape.width * shape.height;\n    case 'triangle':\n      return (shape.base * shape.height) / 2;\n  }\n}\n```\n\nBenefits:\n1. Exhaustive checking\n2. Type narrowing in switch\n3. Impossible states ruled out\n4. Self-documenting"}]}
{"messages":[{"role":"user","content":"Show TypeScript conditional types"},{"role":"assistant","content":"Conditional types for type-level logic:\n\n```typescript\n// ✅ Basic conditional type\ntype IsString<T> = T extends string ? true : false;\ntype A = IsString<string>; // true\ntype B = IsString<number>; // false\n\n// ✅ Extract function return type\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\ntype Func = () => string;\ntype Result = ReturnType<Func>; // string\n\n// ✅ Flatten array types\ntype Flatten<T> = T extends Array<infer U> ? U : T;\ntype Str = Flatten<string[]>; // string\ntype Num = Flatten<number>; // number\n\n// ✅ NonNullable implementation\ntype MyNonNullable<T> = T extends null | undefined ? never : T;\ntype Val = MyNonNullable<string | null>; // string\n\n// ✅ Distributive conditional types\ntype ToArray<T> = T extends any ? T[] : never;\ntype StrOrNumArray = ToArray<string | number>; // string[] | number[]\n\n// ✅ Recursive conditional types\ntype Awaited<T> = T extends Promise<infer U>\n  ? Awaited<U>\n  : T;\ntype Unwrapped = Awaited<Promise<Promise<string>>>; // string\n```\n\nConditional type patterns:\n1. Type-level if/else\n2. Use `infer` to extract types\n3. Distribute over unions\n4. Enable complex type transformations"}]}
{"messages":[{"role":"user","content":"Demonstrate TypeScript template literal types"},{"role":"assistant","content":"Template literal types for string manipulation:\n\n```typescript\n// ✅ String literal combinations\ntype Direction = 'top' | 'bottom' | 'left' | 'right';\ntype Margin = `margin-${Direction}`;\n// 'margin-top' | 'margin-bottom' | 'margin-left' | 'margin-right'\n\n// ✅ Type-safe event names\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype ClickEvent = EventName<'click'>; // 'onClick'\n\n// ✅ CSS property builder\ntype CSSUnit = 'px' | 'em' | 'rem' | '%';\ntype Size = `${number}${CSSUnit}`;\nconst width: Size = '100px'; // ✅\n// const invalid: Size = '100pt'; // ❌\n\n// ✅ Route parameter extraction\ntype ExtractParams<T extends string> = \n  T extends `${infer _Start}:${infer Param}/${infer Rest}`\n    ? Param | ExtractParams<`/${Rest}`>\n    : T extends `${infer _Start}:${infer Param}`\n    ? Param\n    : never;\n\ntype RouteParams = ExtractParams<'/user/:id/post/:postId'>;\n// 'id' | 'postId'\n\n// ✅ Type-safe SQL builder\ntype SQL = `SELECT ${string} FROM ${string}`;\nconst query: SQL = 'SELECT * FROM users'; // ✅\n```\n\nTemplate literal uses:\n1. String pattern validation\n2. API route typing\n3. CSS-in-JS type safety\n4. Event handler naming"}]}
{"messages":[{"role":"user","content":"Show TypeScript mapped types with as clause"},{"role":"assistant","content":"Advanced mapped types:\n\n```typescript\n// ✅ Rename keys with as clause\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype UserGetters = Getters<User>;\n// { getName: () => string; getAge: () => number; }\n\n// ✅ Filter properties by type\ntype OnlyStrings<T> = {\n  [K in keyof T as T[K] extends string ? K : never]: T[K];\n};\n\ntype StringProps = OnlyStrings<User>;\n// { name: string; }\n\n// ✅ Remove optional modifier\ntype Concrete<T> = {\n  [K in keyof T]-?: T[K];\n};\n\ninterface PartialUser {\n  name?: string;\n  age?: number;\n}\n\ntype RequiredUser = Concrete<PartialUser>;\n// { name: string; age: number; }\n\n// ✅ Add readonly modifier\ntype Immutable<T> = {\n  +readonly [K in keyof T]: T[K];\n};\n```\n\nMapped type features:\n1. Key remapping with `as`\n2. Conditional key filtering\n3. Modifier manipulation (+/- readonly, ?)\n4. Transform object shapes"}]}
{"messages":[{"role":"user","content":"Write TypeScript using branded types"},{"role":"assistant","content":"Branded types for nominal typing:\n\n```typescript\n// ✅ Brand primitive types\ntype Brand<K, T> = K & { __brand: T };\n\ntype UserId = Brand<number, 'UserId'>;\ntype ProductId = Brand<number, 'ProductId'>;\n\nfunction createUserId(id: number): UserId {\n  return id as UserId;\n}\n\nfunction createProductId(id: number): ProductId {\n  return id as ProductId;\n}\n\nfunction getUser(id: UserId): User {\n  return database.users.get(id);\n}\n\nconst userId = createUserId(42);\nconst productId = createProductId(42);\n\ngetUser(userId); // ✅ Works\n// getUser(productId); // ❌ Type error!\n// getUser(42); // ❌ Type error!\n\n// ✅ Branded strings for validation\ntype Email = Brand<string, 'Email'>;\n\nfunction createEmail(s: string): Email | null {\n  return /^[^@]+@[^@]+$/.test(s) ? s as Email : null;\n}\n\nfunction sendEmail(to: Email) {\n  // Guaranteed to be valid email format\n}\n```\n\nBranded type benefits:\n1. Prevent mixing similar types\n2. Encode validation in type system\n3. Zero runtime cost\n4. Self-documenting code"}]}
{"messages":[{"role":"user","content":"Show TypeScript const assertions"},{"role":"assistant","content":"Const assertions for literal types:\n\n```typescript\n// ✅ Use as const for literal types\nconst config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\n// config.timeout = 6000; // ❌ Error: readonly\n\ntype Config = typeof config;\n// {\n//   readonly apiUrl: 'https://api.example.com';\n//   readonly timeout: 5000;\n//   readonly retries: 3;\n// }\n\n// ✅ Const arrays preserve tuple types\nconst tuple = [1, 2, 'three'] as const;\ntype Tuple = typeof tuple; // readonly [1, 2, 'three']\n\n// ✅ Use for enum-like constants\nconst STATUSES = ['pending', 'approved', 'rejected'] as const;\ntype Status = typeof STATUSES[number]; // 'pending' | 'approved' | 'rejected'\n\n// ✅ Const assertion in function returns\nfunction getConfig() {\n  return {\n    env: 'production',\n    debug: false,\n  } as const;\n}\n\ntype Env = ReturnType<typeof getConfig>['env']; // 'production'\n\n// ✅ Deep readonly\nconst nested = {\n  user: { name: 'Alice', roles: ['admin', 'user'] },\n} as const;\n\n// nested.user.name = 'Bob'; // ❌ Error\n// nested.user.roles.push('guest'); // ❌ Error\n```\n\nConst assertion uses:\n1. Literal types instead of widened types\n2. Readonly properties\n3. Tuple types from arrays\n4. Type-safe constants"}]}
{"messages":[{"role":"user","content":"Demonstrate TypeScript function overloads"},{"role":"assistant","content":"Function overload patterns:\n\n```typescript\n// ✅ Overload signatures with implementation\nfunction parseValue(value: string): string;\nfunction parseValue(value: number): number;\nfunction parseValue(value: boolean): boolean;\nfunction parseValue(value: string | number | boolean) {\n  return value; // Implementation must handle all cases\n}\n\nconst str = parseValue('hello'); // string\nconst num = parseValue(42); // number\nconst bool = parseValue(true); // boolean\n\n// ✅ Conditional return types\nfunction get(key: 'name'): string;\nfunction get(key: 'age'): number;\nfunction get(key: 'active'): boolean;\nfunction get(key: string): unknown {\n  // Implementation\n  return store[key];\n}\n\nconst name = get('name'); // string\nconst age = get('age'); // number\n\n// ✅ Different arity overloads\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(year: number, month: number, day: number): Date;\nfunction makeDate(yearOrTimestamp: number, month?: number, day?: number): Date {\n  if (month !== undefined && day !== undefined) {\n    return new Date(yearOrTimestamp, month, day);\n  }\n  return new Date(yearOrTimestamp);\n}\n\nconst date1 = makeDate(1234567890);\nconst date2 = makeDate(2024, 0, 1);\n```\n\nOverload guidelines:\n1. More specific before general\n2. Implementation handles all cases\n3. Use for different return types\n4. Alternative: discriminated unions"}]}
{"messages":[{"role":"user","content":"Show TypeScript infer keyword usage"},{"role":"assistant","content":"Type inference with infer:\n\n```typescript\n// ✅ Extract return type\ntype GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\ntype Func = (x: number) => string;\ntype Return = GetReturnType<Func>; // string\n\n// ✅ Extract promise type\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\ntype Data = UnwrapPromise<Promise<string>>; // string\ntype Plain = UnwrapPromise<number>; // number\n\n// ✅ Extract array element type\ntype ElementType<T> = T extends (infer U)[] ? U : never;\ntype Item = ElementType<string[]>; // string\n\n// ✅ Extract function parameters\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\ntype Params = Parameters<(a: string, b: number) => void>; // [string, number]\n\n// ✅ Extract first array element\ntype First<T extends any[]> = T extends [infer F, ...any[]] ? F : never;\ntype FirstItem = First<[string, number, boolean]>; // string\n\n// ✅ Extract object property type\ntype PropType<T, K extends keyof T> = T extends { [key in K]: infer U } ? U : never;\ninterface User { name: string; age: number; }\ntype Name = PropType<User, 'name'>; // string\n\n// ✅ Nested infer\ntype DeepUnwrap<T> = T extends Promise<infer U>\n  ? DeepUnwrap<U>\n  : T extends Array<infer V>\n  ? DeepUnwrap<V>\n  : T;\ntype Unwrapped = DeepUnwrap<Promise<Array<number>>>; // number\n```\n\nInfer patterns:\n1. Extract types from generic positions\n2. Combine with conditional types\n3. Multiple infer in same type\n4. Recursive unwrapping"}]}
{"messages":[{"role":"user","content":"Write TypeScript using readonly arrays and tuples"},{"role":"assistant","content":"Readonly collections for immutability:\n\n```typescript\n// ✅ Readonly arrays prevent mutations\nfunction sum(numbers: readonly number[]): number {\n  // numbers.push(5); // ❌ Error: readonly\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\nconst nums: readonly number[] = [1, 2, 3];\nconst total = sum(nums);\n\n// ✅ ReadonlyArray utility type\nconst items: ReadonlyArray<string> = ['a', 'b', 'c'];\n// items[0] = 'd'; // ❌ Error\n\n// ✅ Readonly tuples\ntype Point = readonly [number, number];\nconst point: Point = [10, 20];\n// point[0] = 30; // ❌ Error\n\n// ✅ As const for readonly literals\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n\n// ✅ Generic readonly function\nfunction first<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n\nconst firstNum = first([1, 2, 3]); // number | undefined\nconst firstStr = first(['a', 'b']); // string | undefined\n\n// ✅ Readonly deep\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object\n    ? DeepReadonly<T[K]>\n    : T[K];\n};\n\ninterface Config {\n  db: { host: string; port: number };\n}\n\ntype ImmutableConfig = DeepReadonly<Config>;\n// { readonly db: { readonly host: string; readonly port: number } }\n```\n\nReadonly benefits:\n1. Prevent accidental mutations\n2. Compiler-enforced immutability\n3. Safe to share references\n4. Better reasoning about code"}]}
{"messages":[{"role":"user","content":"Show TypeScript namespace vs module patterns"},{"role":"assistant","content":"Modern module patterns over namespaces:\n\n```typescript\n// ❌ Avoid namespaces (legacy)\nnamespace Utils {\n  export function format(s: string): string {\n    return s.trim();\n  }\n}\n\n// ✅ Use ES modules instead\n// utils.ts\nexport function format(s: string): string {\n  return s.trim();\n}\n\nexport function capitalize(s: string): string {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n// ✅ Import what you need\nimport { format, capitalize } from './utils';\n\n// ✅ Namespace imports for many exports\nimport * as Utils from './utils';\nUtils.format('hello');\n\n// ✅ Re-export pattern for public API\n// index.ts\nexport { User, createUser } from './user';\nexport { Post, createPost } from './post';\nexport * as utils from './utils';\n\n// ✅ Type-only imports\nimport type { User } from './types';\n\n// ✅ Namespace for declaration merging only\ndeclare namespace NodeJS {\n  interface ProcessEnv {\n    API_KEY: string;\n  }\n}\n```\n\nModule best practices:\n1. Prefer ES modules over namespaces\n2. Use explicit imports/exports\n3. Tree-shakeable\n4. Better tooling support\n5. Namespaces only for declaration merging"}]}
{"messages":[{"role":"user","content":"Demonstrate TypeScript assertion functions"},{"role":"assistant","content":"Assertion functions for type narrowing:\n\n```typescript\n// ✅ Assertion function with asserts keyword\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg || 'Assertion failed');\n  }\n}\n\nfunction processValue(value: unknown) {\n  assert(typeof value === 'string', 'Value must be string');\n  // TypeScript knows value is string here\n  console.log(value.toUpperCase());\n}\n\n// ✅ Type predicate assertion\nfunction assertIsNumber(value: unknown): asserts value is number {\n  if (typeof value !== 'number') {\n    throw new Error('Not a number');\n  }\n}\n\nfunction double(value: unknown): number {\n  assertIsNumber(value);\n  return value * 2; // value is number\n}\n\n// ✅ Non-null assertion function\nfunction assertDefined<T>(value: T | null | undefined): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error('Value is null or undefined');\n  }\n}\n\nfunction getUser(id: number): User | null {\n  return database.find(id);\n}\n\nconst user = getUser(42);\nassertDefined(user);\nconsole.log(user.name); // user is User, not User | null\n\n// ✅ Array element assertion\nfunction assertNonEmpty<T>(arr: T[]): asserts arr is [T, ...T[]] {\n  if (arr.length === 0) {\n    throw new Error('Array is empty');\n  }\n}\n\nfunction processItems(items: string[]) {\n  assertNonEmpty(items);\n  const first = items[0]; // string, not string | undefined\n}\n```\n\nAssertion function uses:\n1. Runtime checks + compile-time narrowing\n2. Throw on invalid input\n3. Type guards with side effects\n4. Cleaner than if + throw"}]}
{"messages":[{"role":"user","content":"Show Python dataclasses with slots"},{"role":"assistant","content":"Dataclasses for clean data structures:\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import List\n\n# ✅ Basic dataclass with slots for memory efficiency\n@dataclass(slots=True)\nclass Point:\n    x: float\n    y: float\n    \n    def distance(self) -> float:\n        return (self.x**2 + self.y**2) ** 0.5\n\np = Point(3.0, 4.0)\nprint(p.distance())  # 5.0\n\n# ✅ Frozen dataclass (immutable)\n@dataclass(frozen=True)\nclass Config:\n    host: str\n    port: int\n    debug: bool = False\n\nconfig = Config('localhost', 8000)\n# config.port = 9000  # ❌ FrozenInstanceError\n\n# ✅ Field with default factory\n@dataclass\nclass User:\n    name: str\n    roles: List[str] = field(default_factory=list)\n    created_at: float = field(default_factory=time.time)\n\n# ✅ Post-init processing\n@dataclass\nclass Rectangle:\n    width: float\n    height: float\n    area: float = field(init=False)\n    \n    def __post_init__(self):\n        self.area = self.width * self.height\n\n# ✅ Order and comparison\n@dataclass(order=True)\nclass Priority:\n    level: int\n    name: str = field(compare=False)\n\ntasks = [Priority(2, 'low'), Priority(1, 'high')]\nsorted_tasks = sorted(tasks)  # Sorted by level\n```\n\nDataclass benefits:\n1. Auto-generated __init__, __repr__, __eq__\n2. Type hints integrated\n3. Slots for memory optimization\n4. Frozen for immutability"}]}
{"messages":[{"role":"user","content":"Write Python using Protocol for structural subtyping"},{"role":"assistant","content":"Protocol for duck typing with type safety:\n\n```python\nfrom typing import Protocol, runtime_checkable\n\n# ✅ Define protocol for structural typing\nclass Drawable(Protocol):\n    def draw(self) -> None:\n        ...\n\nclass Circle:\n    def draw(self) -> None:\n        print(\"Drawing circle\")\n\nclass Square:\n    def draw(self) -> None:\n        print(\"Drawing square\")\n\n# ✅ No inheritance needed\ndef render(obj: Drawable) -> None:\n    obj.draw()\n\nrender(Circle())  # ✅ Works - has draw method\nrender(Square())  # ✅ Works - has draw method\n\n# ✅ Runtime checkable protocol\n@runtime_checkable\nclass Comparable(Protocol):\n    def __lt__(self, other) -> bool:\n        ...\n\ndef is_comparable(obj) -> bool:\n    return isinstance(obj, Comparable)\n\nprint(is_comparable(5))  # True\nprint(is_comparable(\"hello\"))  # True\n\n# ✅ Generic protocol\nfrom typing import TypeVar\n\nT = TypeVar('T')\n\nclass Container(Protocol[T]):\n    def add(self, item: T) -> None:\n        ...\n    \n    def get(self) -> T:\n        ...\n\nclass Stack:\n    def __init__(self):\n        self._items = []\n    \n    def add(self, item: int) -> None:\n        self._items.append(item)\n    \n    def get(self) -> int:\n        return self._items.pop()\n\nstack: Container[int] = Stack()  # ✅ Structural match\n```\n\nProtocol advantages:\n1. Duck typing with type checking\n2. No inheritance required\n3. Gradual typing support\n4. Pythonic interfaces"}]}
{"messages":[{"role":"user","content":"Show Python match statement patterns"},{"role":"assistant","content":"Structural pattern matching (Python 3.10+):\n\n```python\n# ✅ Match with value patterns\ndef http_error(status: int) -> str:\n    match status:\n        case 400:\n            return \"Bad request\"\n        case 404:\n            return \"Not found\"\n        case 418:\n            return \"I'm a teapot\"\n        case _:\n            return \"Unknown error\"\n\n# ✅ Match with OR patterns\nmatch status:\n    case 200 | 201 | 204:\n        return \"Success\"\n    case 400 | 401 | 403:\n        return \"Client error\"\n    case 500 | 502 | 503:\n        return \"Server error\"\n\n# ✅ Structural pattern matching\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\ndef location(point: Point) -> str:\n    match point:\n        case Point(x=0, y=0):\n            return \"Origin\"\n        case Point(x=0, y=y):\n            return f\"Y-axis at {y}\"\n        case Point(x=x, y=0):\n            return f\"X-axis at {x}\"\n        case Point(x=x, y=y) if x == y:\n            return f\"Diagonal at {x}\"\n        case _:\n            return f\"Somewhere else\"\n\n# ✅ Match sequences\ndef parse_command(cmd: list) -> str:\n    match cmd:\n        case [\"quit\"]:\n            return \"Exiting\"\n        case [\"load\", filename]:\n            return f\"Loading {filename}\"\n        case [\"save\", filename, *options]:\n            return f\"Saving {filename} with {options}\"\n        case _:\n            return \"Unknown command\"\n\n# ✅ Match dictionaries\nmatch config:\n    case {\"type\": \"database\", \"host\": host}:\n        connect_db(host)\n    case {\"type\": \"api\", \"url\": url}:\n        connect_api(url)\n```\n\nMatch statement uses:\n1. Cleaner than if/elif chains\n2. Structural decomposition\n3. Guard clauses with if\n4. Exhaustiveness checking"}]}
{"messages":[{"role":"user","content":"Demonstrate Python async context managers"},{"role":"assistant","content":"Async context managers for async resources:\n\n```python\nimport asyncio\nfrom contextlib import asynccontextmanager\n\n# ✅ Async context manager with __aenter__/__aexit__\nclass AsyncDatabase:\n    async def __aenter__(self):\n        self.conn = await connect_to_db()\n        return self.conn\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.conn.close()\n        return False\n\nasync def use_database():\n    async with AsyncDatabase() as conn:\n        result = await conn.query(\"SELECT * FROM users\")\n        return result\n\n# ✅ Async context manager using decorator\n@asynccontextmanager\nasync def async_timer():\n    start = asyncio.get_event_loop().time()\n    try:\n        yield\n    finally:\n        elapsed = asyncio.get_event_loop().time() - start\n        print(f\"Elapsed: {elapsed:.2f}s\")\n\nasync def slow_operation():\n    async with async_timer():\n        await asyncio.sleep(1)\n        # Operation completes\n    # Timer automatically prints elapsed time\n\n# ✅ Nested async context managers\nasync def process_data():\n    async with aiohttp.ClientSession() as session:\n        async with session.get('https://api.example.com') as response:\n            data = await response.json()\n            return data\n\n# ✅ Async context manager for locks\nasync def safe_update():\n    lock = asyncio.Lock()\n    async with lock:\n        # Critical section\n        await update_shared_state()\n```\n\nAsync context manager benefits:\n1. Guaranteed cleanup in async code\n2. Exception-safe resource management\n3. Composable async operations\n4. Clear resource lifecycle"}]}
{"messages":[{"role":"user","content":"Show Python TypedDict for typed dictionaries"},{"role":"assistant","content":"TypedDict for dictionary type hints:\n\n```python\nfrom typing import TypedDict, Required, NotRequired\n\n# ✅ Basic TypedDict\nclass User(TypedDict):\n    name: str\n    age: int\n    email: str\n\ndef create_user(user: User) -> None:\n    print(f\"Creating {user['name']}\")\n\n# ✅ Type checked at static analysis\ncreate_user({\n    'name': 'Alice',\n    'age': 30,\n    'email': 'alice@example.com'\n})  # ✅ Valid\n\n# create_user({'name': 'Bob'})  # ❌ Missing required keys\n\n# ✅ Optional fields with NotRequired (Python 3.11+)\nclass Config(TypedDict):\n    host: str\n    port: int\n    debug: NotRequired[bool]\n\nconfig: Config = {'host': 'localhost', 'port': 8000}  # ✅ debug optional\n\n# ✅ All required with Required (Python 3.11+)\nclass StrictConfig(TypedDict, total=False):\n    host: Required[str]\n    port: int  # Optional\n    debug: int  # Optional\n\n# ✅ Inheritance\nclass BaseUser(TypedDict):\n    name: str\n    email: str\n\nclass AdminUser(BaseUser):\n    permissions: list[str]\n\nadmin: AdminUser = {\n    'name': 'Admin',\n    'email': 'admin@example.com',\n    'permissions': ['read', 'write', 'delete']\n}\n\n# ✅ Generic TypedDict with literal types\nfrom typing import Literal\n\nclass SuccessResponse(TypedDict):\n    status: Literal['success']\n    data: dict\n\nclass ErrorResponse(TypedDict):\n    status: Literal['error']\n    message: str\n\nResponse = SuccessResponse | ErrorResponse\n```\n\nTypedDict benefits:\n1. Type safety for dict structures\n2. Better IDE autocomplete\n3. Static type checking\n4. Common for API responses/configs"}]}
{"messages":[{"role":"user","content":"Write Python using ParamSpec for decorator typing"},{"role":"assistant","content":"ParamSpec for proper decorator types:\n\n```python\nfrom typing import Callable, ParamSpec, TypeVar\nfrom functools import wraps\nimport time\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\n# ✅ Generic decorator preserving signatures\ndef timer(func: Callable[P, T]) -> Callable[P, T]:\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        start = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - start\n        print(f\"{func.__name__} took {elapsed:.2f}s\")\n        return result\n    return wrapper\n\n@timer\ndef process_data(name: str, count: int) -> str:\n    return f\"Processed {count} items for {name}\"\n\n# Type checker knows exact signature\nresult: str = process_data(\"test\", 100)  # ✅ Fully typed\n\n# ✅ Decorator with arguments\ndef retry(max_attempts: int):\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise\n                    print(f\"Retry {attempt + 1}/{max_attempts}\")\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3)\ndef fetch_data(url: str) -> dict:\n    # Network request\n    return {}\n\n# ✅ Async decorator with ParamSpec\nfrom typing import Coroutine\n\nasync def async_timer(\n    func: Callable[P, Coroutine[None, None, T]]\n) -> Callable[P, Coroutine[None, None, T]]:\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        start = time.time()\n        result = await func(*args, **kwargs)\n        print(f\"Async {func.__name__} took {time.time() - start:.2f}s\")\n        return result\n    return wrapper\n```\n\nParamSpec advantages:\n1. Preserves function signatures\n2. Full type safety for decorators\n3. Better IDE support\n4. Correct autocomplete"}]}
{"messages":[{"role":"user","content":"Show Python using Literal types"},{"role":"assistant","content":"Literal types for exact value typing:\n\n```python\nfrom typing import Literal, get_args\n\n# ✅ Literal for exact string values\ndef set_log_level(level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR']):\n    print(f\"Setting log level to {level}\")\n\nset_log_level('INFO')  # ✅ Valid\n# set_log_level('TRACE')  # ❌ Type error\n\n# ✅ Literal with function overloads\nfrom typing import overload\n\n@overload\ndef open_file(path: str, mode: Literal['r']) -> TextIO: ...\n@overload\ndef open_file(path: str, mode: Literal['rb']) -> BinaryIO: ...\n\ndef open_file(path: str, mode: str):\n    return open(path, mode)\n\ntext_file = open_file('file.txt', 'r')  # TextIO\nbinary_file = open_file('file.bin', 'rb')  # BinaryIO\n\n# ✅ Discriminated unions with Literal\nfrom typing import TypedDict\n\nclass SuccessResult(TypedDict):\n    status: Literal['success']\n    data: dict\n\nclass ErrorResult(TypedDict):\n    status: Literal['error']\n    message: str\n\nResult = SuccessResult | ErrorResult\n\ndef handle_result(result: Result):\n    match result['status']:\n        case 'success':\n            print(result['data'])  # Type narrowed to SuccessResult\n        case 'error':\n            print(result['message'])  # Type narrowed to ErrorResult\n\n# ✅ Literal with bool for precise typing\ndef set_flag(flag: Literal[True]) -> None:\n    # Only accepts True, not False or general bool\n    pass\n\nset_flag(True)  # ✅\n# set_flag(False)  # ❌\n\n# ✅ Get literal values at runtime\nLogLevel = Literal['DEBUG', 'INFO', 'WARNING', 'ERROR']\nvalid_levels = get_args(LogLevel)\nprint(valid_levels)  # ('DEBUG', 'INFO', 'WARNING', 'ERROR')\n```\n\nLiteral type uses:\n1. Exact value constraints\n2. Discriminated unions\n3. API mode parameters\n4. Type-safe enums without enums"}]}
{"messages":[{"role":"user","content":"Demonstrate Python generators with type hints"},{"role":"assistant","content":"Generator typing with Generator and yield:\n\n```python\nfrom typing import Generator, Iterator\n\n# ✅ Generator with full type signature\ndef count_up(n: int) -> Generator[int, None, None]:\n    \"\"\"Generator[YieldType, SendType, ReturnType]\"\"\"\n    for i in range(n):\n        yield i\n\nfor num in count_up(5):\n    print(num)  # 0, 1, 2, 3, 4\n\n# ✅ Generator with send\ndef running_average() -> Generator[float, float, None]:\n    total = 0.0\n    count = 0\n    while True:\n        value = yield total / count if count else 0.0\n        total += value\n        count += 1\n\navg = running_average()\nnext(avg)  # Prime the generator\navg.send(10.0)\navg.send(20.0)\nresult = avg.send(30.0)  # Returns average\n\n# ✅ Generator with return value\ndef process_items(items: list[str]) -> Generator[str, None, int]:\n    count = 0\n    for item in items:\n        yield item.upper()\n        count += 1\n    return count  # Generator can return a value\n\ngen = process_items(['a', 'b', 'c'])\nfor item in gen:\n    print(item)\ntry:\n    next(gen)\nexcept StopIteration as e:\n    total = e.value  # Get return value\n    print(f\"Processed {total} items\")\n\n# ✅ Use Iterator for simpler cases\ndef read_lines(filename: str) -> Iterator[str]:\n    with open(filename) as f:\n        for line in f:\n            yield line.strip()\n\n# ✅ Async generator\nfrom typing import AsyncGenerator\n\nasync def async_range(n: int) -> AsyncGenerator[int, None]:\n    for i in range(n):\n        await asyncio.sleep(0.1)\n        yield i\n\nasync for num in async_range(5):\n    print(num)\n```\n\nGenerator typing:\n1. Generator[YieldType, SendType, ReturnType]\n2. Iterator[T] for simple iteration\n3. AsyncGenerator for async iteration\n4. Type-safe yield/send/return"}]}
{"messages":[{"role":"user","content":"Show Python functools patterns"},{"role":"assistant","content":"Functools for functional programming:\n\n```python\nfrom functools import lru_cache, cached_property, partial, reduce, wraps\n\n# ✅ LRU cache for memoization\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(100))  # Computed once, cached\nprint(fibonacci.cache_info())  # CacheInfo(hits=98, misses=101, ...)\n\n# ✅ Cached property for expensive computations\nclass DataProcessor:\n    def __init__(self, data: list[int]):\n        self._data = data\n    \n    @cached_property\n    def statistics(self) -> dict:\n        # Expensive calculation, cached after first access\n        return {\n            'mean': sum(self._data) / len(self._data),\n            'min': min(self._data),\n            'max': max(self._data),\n        }\n\nprocessor = DataProcessor([1, 2, 3, 4, 5])\nstats = processor.statistics  # Computed\nstats2 = processor.statistics  # Cached\n\n# ✅ Partial application\ndef multiply(x: int, y: int) -> int:\n    return x * y\n\ndouble = partial(multiply, 2)\ntriple = partial(multiply, 3)\n\nprint(double(5))  # 10\nprint(triple(5))  # 15\n\n# ✅ Reduce for aggregation\nnumbers = [1, 2, 3, 4, 5]\nproduct = reduce(lambda x, y: x * y, numbers)\nprint(product)  # 120\n\n# ✅ Total ordering from single comparison\nfrom functools import total_ordering\n\n@total_ordering\nclass Version:\n    def __init__(self, major: int, minor: int):\n        self.major = major\n        self.minor = minor\n    \n    def __eq__(self, other):\n        return (self.major, self.minor) == (other.major, other.minor)\n    \n    def __lt__(self, other):\n        return (self.major, self.minor) < (other.major, other.minor)\n    # __le__, __gt__, __ge__ automatically generated\n\nv1 = Version(1, 0)\nv2 = Version(2, 0)\nprint(v1 < v2)  # True\nprint(v1 >= v2)  # False (auto-generated)\n```\n\nFunctools patterns:\n1. lru_cache for performance\n2. cached_property for lazy evaluation\n3. partial for currying\n4. reduce for aggregation\n5. total_ordering to minimize boilerplate"}]}
{"messages":[{"role":"user","content":"Write Python using itertools effectively"},{"role":"assistant","content":"Itertools for efficient iteration:\n\n```python\nfrom itertools import (\n    islice, chain, groupby, product,\n    combinations, permutations, accumulate,\n    takewhile, dropwhile, cycle, repeat\n)\n\n# ✅ islice for lazy slicing\ndef read_file_chunks(filename: str, chunk_size: int):\n    with open(filename) as f:\n        while chunk := list(islice(f, chunk_size)):\n            yield chunk\n\n# ✅ chain for flattening iterables\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist3 = [7, 8, 9]\nflattened = list(chain(list1, list2, list3))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# ✅ groupby for consecutive grouping\ndata = [('A', 1), ('A', 2), ('B', 3), ('B', 4), ('A', 5)]\nfor key, group in groupby(data, key=lambda x: x[0]):\n    print(f\"{key}: {list(group)}\")\n# A: [('A', 1), ('A', 2)]\n# B: [('B', 3), ('B', 4)]\n# A: [('A', 5)]\n\n# ✅ product for Cartesian product\ncolors = ['red', 'blue']\nsizes = ['S', 'M', 'L']\nvariants = list(product(colors, sizes))\n# [('red', 'S'), ('red', 'M'), ('red', 'L'),\n#  ('blue', 'S'), ('blue', 'M'), ('blue', 'L')]\n\n# ✅ combinations and permutations\nitems = ['a', 'b', 'c']\nprint(list(combinations(items, 2)))  # [('a','b'), ('a','c'), ('b','c')]\nprint(list(permutations(items, 2)))  # [('a','b'), ('a','c'), ('b','a'), ...]\n\n# ✅ accumulate for running totals\nnumbers = [1, 2, 3, 4, 5]\nrunning_sum = list(accumulate(numbers))\n# [1, 3, 6, 10, 15]\n\nrunning_product = list(accumulate(numbers, lambda x, y: x * y))\n# [1, 2, 6, 24, 120]\n\n# ✅ takewhile and dropwhile for conditional iteration\ndata = [1, 4, 6, 4, 1]\nprint(list(takewhile(lambda x: x < 5, data)))  # [1, 4]\nprint(list(dropwhile(lambda x: x < 5, data)))  # [6, 4, 1]\n\n# ✅ cycle for infinite repetition with limit\ncolors = cycle(['red', 'green', 'blue'])\nfirst_10 = list(islice(colors, 10))\n```\n\nItertools benefits:\n1. Memory efficient (lazy evaluation)\n2. Composable operations\n3. Fast C implementations\n4. Functional programming patterns"}]}
{"messages":[{"role":"user","content":"Show Go error wrapping with fmt.Errorf"},{"role":"assistant","content":"Error wrapping for context:\n\n```go\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\n// ✅ Wrap errors with %w verb\nfunc readConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config: %w\", err)\n    }\n    \n    var config Config\n    if err := json.Unmarshal(data, &config); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config: %w\", err)\n    }\n    \n    return &config, nil\n}\n\n// ✅ Unwrap errors with errors.Is and errors.As\nfunc handleError(err error) {\n    // Check for specific error type\n    if errors.Is(err, os.ErrNotExist) {\n        fmt.Println(\"File doesn't exist\")\n        return\n    }\n    \n    // Extract error value\n    var pathErr *os.PathError\n    if errors.As(err, &pathErr) {\n        fmt.Printf(\"Path error: %s\\n\", pathErr.Path)\n        return\n    }\n    \n    fmt.Printf(\"Unknown error: %v\\n\", err)\n}\n\n// ✅ Custom error types\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Err   error\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for %s=%v: %v\", e.Field, e.Value, e.Err)\n}\n\nfunc (e *ValidationError) Unwrap() error {\n    return e.Err\n}\n\n// ✅ Multiple error wrapping\nfunc processFile(path string) error {\n    if err := validate(path); err != nil {\n        return fmt.Errorf(\"validation: %w\", err)\n    }\n    \n    if err := transform(path); err != nil {\n        return fmt.Errorf(\"transform: %w\", err)\n    }\n    \n    return nil\n}\n\nerr := processFile(\"data.json\")\nif err != nil {\n    fmt.Printf(\"Error chain: %v\\n\", err)\n    // Error chain: transform: validation: file too large\n}\n```\n\nError wrapping best practices:\n1. Use %w to preserve error chain\n2. errors.Is for sentinel errors\n3. errors.As for error types\n4. Add context at each layer"}]}
{"messages":[{"role":"user","content":"Demonstrate Go table-driven tests"},{"role":"assistant","content":"Table-driven tests for comprehensive coverage:\n\n```go\nimport \"testing\"\n\n// ✅ Basic table-driven test\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name     string\n        a, b     int\n        expected int\n    }{\n        {\"positive numbers\", 2, 3, 5},\n        {\"negative numbers\", -2, -3, -5},\n        {\"mixed signs\", -2, 3, 1},\n        {\"zeros\", 0, 0, 0},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d, want %d\",\n                    tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n\n// ✅ Table test with error cases\nfunc TestParseEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        want    string\n        wantErr bool\n    }{\n        {\"valid email\", \"user@example.com\", \"user@example.com\", false},\n        {\"missing @\", \"userexample.com\", \"\", true},\n        {\"empty string\", \"\", \"\", true},\n        {\"spaces\", \"user @example.com\", \"\", true},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := ParseEmail(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"ParseEmail() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if got != tt.want {\n                t.Errorf(\"ParseEmail() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\n// ✅ Parallel table tests\nfunc TestConcurrent(t *testing.T) {\n    tests := []struct {\n        name string\n        fn   func() int\n        want int\n    }{\n        {\"test1\", func1, 42},\n        {\"test2\", func2, 100},\n    }\n    \n    for _, tt := range tests {\n        tt := tt  // Capture range variable\n        t.Run(tt.name, func(t *testing.T) {\n            t.Parallel()  // Run in parallel\n            if got := tt.fn(); got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}\n```\n\nTable-driven test benefits:\n1. Easy to add new test cases\n2. Clear test data structure\n3. Run subtests with t.Run\n4. Parallel execution support"}]}
{"messages":[{"role":"user","content":"Show Go functional options pattern"},{"role":"assistant","content":"Functional options for flexible APIs:\n\n```go\n// ✅ Server with functional options\ntype Server struct {\n    host    string\n    port    int\n    timeout time.Duration\n    tls     *tls.Config\n}\n\ntype Option func(*Server)\n\n// Option constructors\nfunc WithHost(host string) Option {\n    return func(s *Server) {\n        s.host = host\n    }\n}\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = timeout\n    }\n}\n\nfunc WithTLS(config *tls.Config) Option {\n    return func(s *Server) {\n        s.tls = config\n    }\n}\n\n// Constructor with variadic options\nfunc NewServer(opts ...Option) *Server {\n    // Default values\n    s := &Server{\n        host:    \"localhost\",\n        port:    8080,\n        timeout: 30 * time.Second,\n    }\n    \n    // Apply options\n    for _, opt := range opts {\n        opt(s)\n    }\n    \n    return s\n}\n\n// ✅ Usage is clean and flexible\nserver1 := NewServer()\n\nserver2 := NewServer(\n    WithHost(\"0.0.0.0\"),\n    WithPort(9000),\n)\n\nserver3 := NewServer(\n    WithHost(\"api.example.com\"),\n    WithPort(443),\n    WithTLS(tlsConfig),\n    WithTimeout(60 * time.Second),\n)\n\n// ✅ Options can have validation\nfunc WithValidatedPort(port int) Option {\n    return func(s *Server) {\n        if port < 1 || port > 65535 {\n            s.port = 8080  // fallback\n        } else {\n            s.port = port\n        }\n    }\n}\n```\n\nFunctional options benefits:\n1. Backward compatible (add options without breaking)\n2. Self-documenting API\n3. No nil parameters\n4. Optional configuration with defaults"}]}
{"messages":[{"role":"user","content":"Write Go code using embedding for composition"},{"role":"assistant","content":"Struct embedding for composition:\n\n```go\n// ✅ Embed structs for composition\ntype User struct {\n    Name  string\n    Email string\n}\n\nfunc (u User) String() string {\n    return fmt.Sprintf(\"%s <%s>\", u.Name, u.Email)\n}\n\ntype Admin struct {\n    User           // Embedded field\n    Permissions    []string\n}\n\n// ✅ Promoted fields and methods\nadmin := Admin{\n    User: User{\n        Name:  \"Alice\",\n        Email: \"alice@example.com\",\n    },\n    Permissions: []string{\"read\", \"write\", \"delete\"},\n}\n\n// Access embedded fields directly\nfmt.Println(admin.Name)   // \"Alice\" (promoted)\nfmt.Println(admin.String()) // Uses User.String()\n\n// ✅ Interface embedding\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype ReadWriter interface {\n    Reader  // Embed interface\n    Writer  // Embed interface\n}\n\n// ✅ Embed multiple structs\ntype Timestamped struct {\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}\n\ntype Post struct {\n    User        // Author info\n    Timestamped // Timestamps\n    Title       string\n    Content     string\n}\n\npost := Post{\n    User: User{Name: \"Bob\", Email: \"bob@example.com\"},\n    Timestamped: Timestamped{\n        CreatedAt: time.Now(),\n        UpdatedAt: time.Now(),\n    },\n    Title:   \"My Post\",\n    Content: \"Content here\",\n}\n\nfmt.Println(post.Name)      // From User\nfmt.Println(post.CreatedAt) // From Timestamped\n\n// ✅ Override embedded methods\ntype EnhancedAdmin struct {\n    Admin\n}\n\nfunc (ea EnhancedAdmin) String() string {\n    return fmt.Sprintf(\"Admin: %s\", ea.Admin.String())\n}\n```\n\nEmbedding benefits:\n1. Composition over inheritance\n2. Promoted fields/methods\n3. Interface composition\n4. Clean delegation"}]}
{"messages":[{"role":"user","content":"Show Go context patterns"},{"role":"assistant","content":"Context for cancellation and deadlines:\n\n```go\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\n// ✅ Context with timeout\nfunc fetchWithTimeout(url string) (*Response, error) {\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()  // Always call cancel to release resources\n    \n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n    \n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"request failed: %w\", err)\n    }\n    \n    return resp, nil\n}\n\n// ✅ Context with cancellation\nfunc worker(ctx context.Context, id int) {\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Printf(\"Worker %d: %v\\n\", id, ctx.Err())\n            return\n        default:\n            // Do work\n            time.Sleep(100 * time.Millisecond)\n        }\n    }\n}\n\nctx, cancel := context.WithCancel(context.Background())\ngo worker(ctx, 1)\ngo worker(ctx, 2)\n\ntime.Sleep(1 * time.Second)\ncancel()  // Cancel all workers\n\n// ✅ Context with values (use sparingly)\ntype contextKey string\n\nconst userIDKey contextKey = \"userID\"\n\nfunc WithUserID(ctx context.Context, userID int) context.Context {\n    return context.WithValue(ctx, userIDKey, userID)\n}\n\nfunc GetUserID(ctx context.Context) (int, bool) {\n    userID, ok := ctx.Value(userIDKey).(int)\n    return userID, ok\n}\n\n// ✅ Chain contexts\nfunc processRequest(parentCtx context.Context) error {\n    // Create child context with timeout\n    ctx, cancel := context.WithTimeout(parentCtx, 10*time.Second)\n    defer cancel()\n    \n    // Pass to downstream operations\n    return doWork(ctx)\n}\n\n// ✅ Context in struct (anti-pattern, avoid)\n// ❌ Don't store context in structs\ntype BadServer struct {\n    ctx context.Context  // Don't do this\n}\n\n// ✅ Pass context as first parameter\nfunc (s *Server) Handle(ctx context.Context, req *Request) error {\n    // Good: context is parameter\n    return s.process(ctx, req)\n}\n```\n\nContext best practices:\n1. Always pass as first parameter\n2. Call cancel() to avoid leaks\n3. Use for cancellation, deadlines, request-scoped values\n4. Don't store in structs"}]}
{"messages":[{"role":"user","content":"Demonstrate Go sync.Once for lazy initialization"},{"role":"assistant","content":"sync.Once for thread-safe initialization:\n\n```go\nimport (\n    \"sync\"\n)\n\n// ✅ Singleton pattern with sync.Once\ntype Database struct {\n    conn *sql.DB\n}\n\nvar (\n    db   *Database\n    once sync.Once\n)\n\nfunc GetDatabase() *Database {\n    once.Do(func() {\n        conn, err := sql.Open(\"postgres\", \"connection-string\")\n        if err != nil {\n            panic(err)  // Or handle appropriately\n        }\n        db = &Database{conn: conn}\n    })\n    return db\n}\n\n// ✅ Lazy initialization of expensive resources\ntype Cache struct {\n    data map[string]string\n    mu   sync.RWMutex\n    once sync.Once\n}\n\nfunc (c *Cache) init() {\n    c.once.Do(func() {\n        c.data = make(map[string]string)\n        // Load data from disk or remote\n        c.loadData()\n    })\n}\n\nfunc (c *Cache) Get(key string) string {\n    c.init()  // Ensures initialization happens once\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    return c.data[key]\n}\n\nfunc (c *Cache) Set(key, value string) {\n    c.init()\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.data[key] = value\n}\n\n// ✅ One-time setup\ntype Server struct {\n    setupOnce sync.Once\n    config    *Config\n}\n\nfunc (s *Server) ensureSetup() {\n    s.setupOnce.Do(func() {\n        s.config = loadConfig()\n        s.initializeMetrics()\n        s.registerHandlers()\n    })\n}\n\nfunc (s *Server) Start() error {\n    s.ensureSetup()  // Called multiple times, runs once\n    return s.listen()\n}\n```\n\nsync.Once benefits:\n1. Thread-safe initialization\n2. Exactly once execution\n3. Lazy loading\n4. Singleton pattern"}]}
{"messages":[{"role":"user","content":"Show Go generics with constraints"},{"role":"assistant","content":"Generics for type-safe reusable code:\n\n```go\nimport \"golang.org/x/exp/constraints\"\n\n// ✅ Generic function with type parameter\nfunc Map[T any, U any](slice []T, fn func(T) U) []U {\n    result := make([]U, len(slice))\n    for i, v := range slice {\n        result[i] = fn(v)\n    }\n    return result\n}\n\nnumbers := []int{1, 2, 3, 4}\nstrings := Map(numbers, func(n int) string {\n    return fmt.Sprintf(\"%d\", n)\n})\n// [\"1\", \"2\", \"3\", \"4\"]\n\n// ✅ Constraint with built-in interfaces\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nminInt := Min(5, 10)        // 5\nminFloat := Min(3.14, 2.71) // 2.71\nminString := Min(\"b\", \"a\")  // \"a\"\n\n// ✅ Custom constraint\ntype Number interface {\n    int | int64 | float64\n}\n\nfunc Sum[T Number](numbers []T) T {\n    var sum T\n    for _, n := range numbers {\n        sum += n\n    }\n    return sum\n}\n\n// ✅ Generic data structures\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\nintStack := &Stack[int]{}\nintStack.Push(42)\n\nstringStack := &Stack[string]{}\nstringStack.Push(\"hello\")\n\n// ✅ Method with type parameter\ntype Container[T any] struct {\n    value T\n}\n\nfunc (c Container[T]) Get() T {\n    return c.value\n}\n\nfunc (c *Container[T]) Set(value T) {\n    c.value = value\n}\n\nc := Container[int]{value: 42}\nval := c.Get()  // 42\nc.Set(100)\n```\n\nGenerics best practices:\n1. Use constraints.Ordered for comparable types\n2. Custom constraints for specific operations\n3. Generic data structures\n4. Type inference when possible"}]}
{"messages":[{"role":"user","content":"Write Go code with proper buffered channels"},{"role":"assistant","content":"Buffered channels for performance:\n\n```go\n// ✅ Buffered channel for work queue\nfunc processJobs(jobs []Job) {\n    // Buffer size matches number of workers\n    jobQueue := make(chan Job, 10)\n    results := make(chan Result, 10)\n    \n    // Start workers\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            for job := range jobQueue {\n                result := process(job)\n                results <- result\n            }\n        }(i)\n    }\n    \n    // Send jobs\n    go func() {\n        for _, job := range jobs {\n            jobQueue <- job\n        }\n        close(jobQueue)  // Signal no more jobs\n    }()\n    \n    // Collect results in separate goroutine\n    go func() {\n        wg.Wait()\n        close(results)  // Close results after all workers done\n    }()\n    \n    // Process results\n    for result := range results {\n        fmt.Println(result)\n    }\n}\n\n// ✅ Rate limiting with buffered channel\ntype RateLimiter struct {\n    tokens chan struct{}\n}\n\nfunc NewRateLimiter(requestsPerSecond int) *RateLimiter {\n    rl := &RateLimiter{\n        tokens: make(chan struct{}, requestsPerSecond),\n    }\n    \n    // Refill tokens\n    go func() {\n        ticker := time.NewTicker(time.Second / time.Duration(requestsPerSecond))\n        defer ticker.Stop()\n        for range ticker.C {\n            select {\n            case rl.tokens <- struct{}{}:\n            default:  // Channel full, skip\n            }\n        }\n    }()\n    \n    return rl\n}\n\nfunc (rl *RateLimiter) Wait() {\n    <-rl.tokens  // Block until token available\n}\n\n// ✅ Pipeline with buffered stages\nfunc pipeline(input []int) <-chan int {\n    // Stage 1: Generate numbers\n    gen := make(chan int, 10)\n    go func() {\n        for _, n := range input {\n            gen <- n\n        }\n        close(gen)\n    }()\n    \n    // Stage 2: Square numbers\n    squared := make(chan int, 10)\n    go func() {\n        for n := range gen {\n            squared <- n * n\n        }\n        close(squared)\n    }()\n    \n    // Stage 3: Filter even numbers\n    filtered := make(chan int, 10)\n    go func() {\n        for n := range squared {\n            if n%2 == 0 {\n                filtered <- n\n            }\n        }\n        close(filtered)\n    }()\n    \n    return filtered\n}\n```\n\nBuffered channel guidelines:\n1. Size matches concurrency level\n2. Prevents blocking senders/receivers\n3. Use for work queues and pipelines\n4. Always close channels when done"}]}
{"messages":[{"role":"user","content":"Show Go method receivers: pointer vs value"},{"role":"assistant","content":"Choosing pointer vs value receivers:\n\n```go\n// ✅ Value receiver for small, immutable types\ntype Point struct {\n    X, Y float64\n}\n\n// Value receiver: doesn't modify original\nfunc (p Point) Distance() float64 {\n    return math.Sqrt(p.X*p.X + p.Y*p.Y)\n}\n\np := Point{X: 3, Y: 4}\ndist := p.Distance()  // Returns 5.0\n\n// ✅ Pointer receiver for mutations\ntype Counter struct {\n    count int\n}\n\n// Pointer receiver: modifies original\nfunc (c *Counter) Increment() {\n    c.count++\n}\n\nfunc (c *Counter) Value() int {\n    return c.count  // Can use pointer receiver for read-only too\n}\n\nc := &Counter{}\nc.Increment()\nfmt.Println(c.Value())  // 1\n\n// ✅ Pointer receiver for large structs (avoid copying)\ntype LargeData struct {\n    data [1000000]int\n}\n\n// Avoid copying large struct\nfunc (ld *LargeData) Process() {\n    // Process data without copying\n}\n\n// ✅ Consistency: if one method uses pointer, use for all\ntype User struct {\n    name  string\n    email string\n}\n\n// All methods use pointer receiver for consistency\nfunc (u *User) SetName(name string) {\n    u.name = name\n}\n\nfunc (u *User) SetEmail(email string) {\n    u.email = email\n}\n\nfunc (u *User) String() string {\n    return fmt.Sprintf(\"%s <%s>\", u.name, u.email)\n}\n\n// ✅ Interface implementation consideration\ntype Stringer interface {\n    String() string\n}\n\n// Value receiver satisfies interface for both T and *T\nfunc (p Point) String() string {\n    return fmt.Sprintf(\"(%f, %f)\", p.X, p.Y)\n}\n\nvar s1 Stringer = Point{1, 2}   // ✅ Works\nvar s2 Stringer = &Point{1, 2}  // ✅ Works\n\n// Pointer receiver only satisfies interface for *T\nfunc (c *Counter) String() string {\n    return fmt.Sprintf(\"Count: %d\", c.count)\n}\n\n// var s3 Stringer = Counter{}   // ❌ Doesn't work\nvar s4 Stringer = &Counter{}     // ✅ Works\n```\n\nReceiver guidelines:\n1. Pointer if method modifies receiver\n2. Pointer for large structs\n3. Value for small, immutable types\n4. Be consistent across methods\n5. Consider interface requirements"}]}
{"messages":[{"role":"user","content":"Demonstrate Go init functions and package initialization"},{"role":"assistant","content":"Package initialization order:\n\n```go\npackage myapp\n\nimport (\n    \"database/sql\"\n    \"log\"\n)\n\n// ✅ Package-level variables initialized in declaration order\nvar (\n    // 1. Constants first\n    defaultTimeout = 30 * time.Second\n    \n    // 2. Variables without dependencies\n    logger = log.New(os.Stdout, \"APP: \", log.LstdFlags)\n    \n    // 3. Variables with dependencies\n    config = loadConfig()  // Called at init time\n)\n\n// ✅ init functions run after variable initialization\nfunc init() {\n    // Runs automatically before main()\n    logger.Println(\"Initializing application\")\n    \n    // Register database drivers\n    sql.Register(\"custom\", &CustomDriver{})\n    \n    // Set up global state (use sparingly)\n    rand.Seed(time.Now().UnixNano())\n}\n\n// ✅ Multiple init functions execute in order\nfunc init() {\n    logger.Println(\"Second init function\")\n}\n\nfunc init() {\n    logger.Println(\"Third init function\")\n}\n\n// ✅ Common init patterns\nvar db *sql.DB\n\nfunc init() {\n    var err error\n    db, err = sql.Open(\"postgres\", os.Getenv(\"DATABASE_URL\"))\n    if err != nil {\n        log.Fatal(\"Failed to connect to database:\", err)\n    }\n    \n    if err := db.Ping(); err != nil {\n        log.Fatal(\"Database not reachable:\", err)\n    }\n}\n\n// ✅ Blank import for side effects\nimport (\n    _ \"github.com/lib/pq\"  // PostgreSQL driver registers itself in init\n)\n\n// ✅ Avoid complex init - prefer explicit initialization\n// ❌ Bad: complex logic in init\nfunc init() {\n    // Heavy computation\n    // Network calls\n    // File I/O\n}\n\n// ✅ Good: lazy initialization\nvar (\n    cache     *Cache\n    cacheOnce sync.Once\n)\n\nfunc GetCache() *Cache {\n    cacheOnce.Do(func() {\n        cache = loadCache()  // Lazy, explicit\n    })\n    return cache\n}\n```\n\nInit function guidelines:\n1. Keep init functions simple\n2. Use for registration/setup only\n3. Avoid external dependencies\n4. Prefer explicit initialization\n5. Multiple init funcs run in order"}]}
{"messages":[{"role":"user","content":"Show Rust using Result combinators instead of match"},{"role":"assistant","content":"Result combinators for cleaner error handling:\n\n```rust\n// ❌ Verbose match\nfn parse_and_double(s: &str) -> Result<i32, ParseIntError> {\n    match s.parse::<i32>() {\n        Ok(n) => Ok(n * 2),\n        Err(e) => Err(e),\n    }\n}\n\n// ✅ Use map combinator\nfn parse_and_double(s: &str) -> Result<i32, ParseIntError> {\n    s.parse::<i32>().map(|n| n * 2)\n}\n\n// ❌ Nested match for multiple operations\nfn process(s: &str) -> Result<i32, Box<dyn Error>> {\n    match s.parse::<i32>() {\n        Ok(n) => match validate(n) {\n            Ok(valid) => Ok(valid * 2),\n            Err(e) => Err(e),\n        },\n        Err(e) => Err(Box::new(e)),\n    }\n}\n\n// ✅ Chain with and_then\nfn process(s: &str) -> Result<i32, Box<dyn Error>> {\n    s.parse::<i32>()\n        .map_err(|e| Box::new(e) as Box<dyn Error>)\n        .and_then(|n| validate(n))\n        .map(|n| n * 2)\n}\n\n// ✅ Use unwrap_or for defaults\nlet value = config.get(\"timeout\")\n    .unwrap_or(30);\n\n// ✅ Use unwrap_or_else for lazy defaults\nlet conn = pool.get()\n    .unwrap_or_else(|_| create_connection());\n\n// ✅ Use ok_or to convert Option to Result\nfn find_user(id: u32) -> Result<User, Error> {\n    users.get(&id)\n        .ok_or(Error::NotFound)\n}\n```\n\nCombinator benefits:\n1. More concise than match\n2. Chainable operations\n3. Functional programming style\n4. Common in idiomatic Rust"}]}
{"messages":[{"role":"user","content":"Write Rust using Option combinators effectively"},{"role":"assistant","content":"Option combinators for elegant None handling:\n\n```rust\n// ❌ Verbose if let\nfn get_username(user: Option<User>) -> String {\n    if let Some(u) = user {\n        u.name\n    } else {\n        String::from(\"Guest\")\n    }\n}\n\n// ✅ Use map_or\nfn get_username(user: Option<User>) -> String {\n    user.map_or(String::from(\"Guest\"), |u| u.name)\n}\n\n// ✅ Use and_then for chaining\nfn get_user_email(id: u32) -> Option<String> {\n    find_user(id)\n        .and_then(|user| user.profile)\n        .and_then(|profile| profile.email)\n}\n\n// ✅ Use filter for conditional Some\nfn find_adult(user: Option<User>) -> Option<User> {\n    user.filter(|u| u.age >= 18)\n}\n\n// ✅ Use or_else for fallback computation\nlet config = load_from_file()\n    .or_else(|| load_from_env())\n    .or_else(|| load_defaults());\n\n// ✅ Use take to move out of Option\nstruct Cache {\n    data: Option<Vec<u8>>,\n}\n\nimpl Cache {\n    fn consume(&mut self) -> Option<Vec<u8>> {\n        self.data.take()  // Leaves None in place\n    }\n}\n\n// ✅ Use flatten for nested Options\nlet nested: Option<Option<i32>> = Some(Some(42));\nlet flattened: Option<i32> = nested.flatten();  // Some(42)\n```\n\nOption combinator patterns:\n1. map for transformations\n2. and_then for chaining\n3. filter for conditional Some\n4. unwrap_or/unwrap_or_else for defaults"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust iterator chains over manual loops"},{"role":"assistant","content":"Iterator chains for expressive code:\n\n```rust\n// ❌ Manual loop\nfn sum_even_squares(numbers: &[i32]) -> i32 {\n    let mut sum = 0;\n    for &n in numbers {\n        if n % 2 == 0 {\n            sum += n * n;\n        }\n    }\n    sum\n}\n\n// ✅ Iterator chain\nfn sum_even_squares(numbers: &[i32]) -> i32 {\n    numbers.iter()\n        .filter(|&&n| n % 2 == 0)\n        .map(|&n| n * n)\n        .sum()\n}\n\n// ❌ Collect with manual loop\nfn to_uppercase(words: Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    for word in words {\n        result.push(word.to_uppercase());\n    }\n    result\n}\n\n// ✅ Map and collect\nfn to_uppercase(words: Vec<String>) -> Vec<String> {\n    words.into_iter()\n        .map(|s| s.to_uppercase())\n        .collect()\n}\n\n// ✅ Use enumerate for indexed iteration\nfor (index, value) in items.iter().enumerate() {\n    println!(\"Item {}: {}\", index, value);\n}\n\n// ✅ Use zip to iterate pairs\nlet names = vec![\"Alice\", \"Bob\"];\nlet ages = vec![30, 25];\n\nfor (name, age) in names.iter().zip(ages.iter()) {\n    println!(\"{} is {} years old\", name, age);\n}\n\n// ✅ Use take and skip for slicing\nlet first_five: Vec<_> = items.iter().take(5).collect();\nlet skip_first: Vec<_> = items.iter().skip(3).collect();\n\n// ✅ Use partition for splitting\nlet (evens, odds): (Vec<_>, Vec<_>) = numbers.iter()\n    .partition(|&&n| n % 2 == 0);\n```\n\nIterator advantages:\n1. Zero-cost abstraction\n2. Composable operations\n3. Lazy evaluation\n4. More concise than loops"}]}
{"messages":[{"role":"user","content":"Show Rust using &str parameters instead of String"},{"role":"assistant","content":"Prefer &str for function parameters:\n\n```rust\n// ❌ Takes ownership unnecessarily\nfn print_message(msg: String) {\n    println!(\"{}\", msg);\n}  // msg dropped here\n\nlet message = String::from(\"Hello\");\nprint_message(message);\n// Can't use message anymore!\n\n// ✅ Borrow with &str\nfn print_message(msg: &str) {\n    println!(\"{}\", msg);\n}\n\nlet message = String::from(\"Hello\");\nprint_message(&message);\nprint_message(&message);  // ✅ Can reuse\n\n// ✅ Works with both String and &str\nfn process(text: &str) -> usize {\n    text.len()\n}\n\nlet s = String::from(\"hello\");\nlet len1 = process(&s);         // String\nlet len2 = process(\"world\");    // &str literal\n\n// ❌ String parameter forces allocation\nfn greet(name: String) {\n    println!(\"Hello, {}\", name);\n}\n\ngreet(\"Alice\".to_string());  // Unnecessary allocation\n\n// ✅ &str parameter, no allocation\nfn greet(name: &str) {\n    println!(\"Hello, {}\", name);\n}\n\ngreet(\"Alice\");  // No allocation needed\n\n// ✅ Return String when you create new data\nfn make_greeting(name: &str) -> String {\n    format!(\"Hello, {}!\", name)  // Creates new String\n}\n\n// ✅ Return &str when returning a slice\nfn first_word(s: &str) -> &str {\n    s.split_whitespace().next().unwrap_or(\"\")\n}\n```\n\nString vs &str guidelines:\n1. Parameters: prefer &str (flexible)\n2. Return: String if owned, &str if borrowed\n3. &str works with both String and literals\n4. Avoids unnecessary allocations"}]}
{"messages":[{"role":"user","content":"Write Rust using into() for generic conversions"},{"role":"assistant","content":"Use into() for implicit conversions:\n\n```rust\nuse std::path::PathBuf;\n\n// ❌ Explicit type conversions\nfn open_file(path: String) -> Result<File, Error> {\n    File::open(PathBuf::from(path))\n}\n\nlet file = open_file(\"data.txt\".to_string());\n\n// ✅ Accept any type that converts to PathBuf\nfn open_file(path: impl Into<PathBuf>) -> Result<File, Error> {\n    File::open(path.into())\n}\n\nlet file1 = open_file(\"data.txt\");           // &str\nlet file2 = open_file(String::from(\"test\")); // String\nlet file3 = open_file(PathBuf::from(\"/tmp\")); // PathBuf\n\n// ✅ Generic String/&str parameters\nfn process(name: impl Into<String>) {\n    let name: String = name.into();\n    println!(\"Processing {}\", name);\n}\n\nprocess(\"test\");                  // &str\nprocess(String::from(\"test\"));    // String\n\n// ✅ Builder pattern with into()\nstruct Config {\n    host: String,\n    port: u16,\n}\n\nimpl Config {\n    fn new(host: impl Into<String>, port: u16) -> Self {\n        Self {\n            host: host.into(),\n            port,\n        }\n    }\n}\n\nlet config1 = Config::new(\"localhost\", 8080);\nlet config2 = Config::new(String::from(\"0.0.0.0\"), 9000);\n\n// ✅ Cow for flexible ownership\nuse std::borrow::Cow;\n\nfn process_data(data: Cow<str>) {\n    match data {\n        Cow::Borrowed(s) => println!(\"Borrowed: {}\", s),\n        Cow::Owned(s) => println!(\"Owned: {}\", s),\n    }\n}\n\nprocess_data(\"static\".into());           // Borrowed\nprocess_data(String::from(\"owned\").into()); // Owned\n```\n\ninto() benefits:\n1. Flexible function signatures\n2. Caller controls allocation\n3. Works with multiple types\n4. Common in builder APIs"}]}
{"messages":[{"role":"user","content":"Show Rust using impl Trait for return types"},{"role":"assistant","content":"impl Trait for cleaner return types:\n\n```rust\nuse std::fmt::Display;\n\n// ❌ Verbose trait object\nfn get_formatter() -> Box<dyn Display> {\n    Box::new(42)\n}\n\n// ✅ Use impl Trait (zero cost)\nfn get_formatter() -> impl Display {\n    42  // No heap allocation\n}\n\n// ✅ Return closures\nfn make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\nlet add_five = make_adder(5);\nassert_eq!(add_five(10), 15);\n\n// ✅ Return iterators without naming type\nfn evens(n: i32) -> impl Iterator<Item = i32> {\n    (0..n).filter(|x| x % 2 == 0)\n}\n\nfor num in evens(10) {\n    println!(\"{}\", num);\n}\n\n// ✅ Combine multiple traits\nfn get_value() -> impl Display + Clone + Send {\n    42\n}\n\n// ⚠️ Can't return different types\n// This won't compile:\n// fn get_number(flag: bool) -> impl Display {\n//     if flag {\n//         42        // i32\n//     } else {\n//         \"hello\"  // &str - different type!\n//     }\n// }\n\n// ✅ Use trait object for different types\nfn get_number(flag: bool) -> Box<dyn Display> {\n    if flag {\n        Box::new(42)\n    } else {\n        Box::new(\"hello\")\n    }\n}\n\n// ✅ async fn returns impl Future\nasync fn fetch_data() -> Result<String, Error> {\n    // Returns impl Future<Output = Result<String, Error>>\n    Ok(String::from(\"data\"))\n}\n```\n\nimpl Trait advantages:\n1. Zero-cost abstraction\n2. No heap allocation\n3. Cleaner signatures\n4. Great for iterators/closures"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust using derive macros for common traits"},{"role":"assistant","content":"Derive macros to reduce boilerplate:\n\n```rust\n// ✅ Always derive common traits\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n\nlet user1 = User {\n    name: String::from(\"Alice\"),\n    age: 30,\n};\nlet user2 = user1.clone();\nprintln!(\"{:?}\", user1);  // Debug\nassert_eq!(user1, user2);  // PartialEq\n\n// ✅ Derive for enums\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nenum Status {\n    Pending,\n    Active,\n    Completed,\n}\n\nuse std::collections::HashMap;\nlet mut status_counts = HashMap::new();\nstatus_counts.insert(Status::Active, 5);  // Hash trait\n\n// ✅ Derive Default for initialization\n#[derive(Debug, Default)]\nstruct Config {\n    host: String,  // Default: \"\"\n    port: u16,     // Default: 0\n}\n\nlet config = Config::default();\n\n// ✅ Custom Default with attributes\n#[derive(Debug)]\nstruct Server {\n    #[default = \"localhost\"]\n    host: String,\n    port: u16,\n}\n\nimpl Default for Server {\n    fn default() -> Self {\n        Self {\n            host: String::from(\"localhost\"),\n            port: 8080,\n        }\n    }\n}\n\n// ✅ Derive Ord for sorting\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\nstruct Version {\n    major: u32,\n    minor: u32,\n    patch: u32,\n}\n\nlet mut versions = vec![\n    Version { major: 1, minor: 2, patch: 0 },\n    Version { major: 1, minor: 1, patch: 5 },\n];\nversions.sort();  // Uses Ord trait\n\n// ✅ Serde for serialization\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nlet json = serde_json::to_string(&person)?;\nlet person: Person = serde_json::from_str(&json)?;\n```\n\nCommon derive traits:\n1. Debug - for debugging output\n2. Clone - for explicit copying\n3. Copy - for implicit copying (small types)\n4. PartialEq/Eq - for equality\n5. Default - for default values\n6. Serialize/Deserialize - for JSON/etc"}]}
{"messages":[{"role":"user","content":"Show Rust using newtype pattern for type safety"},{"role":"assistant","content":"Newtype pattern for compile-time safety:\n\n```rust\n// ❌ Primitive obsession\nfn transfer(from: u32, to: u32, amount: f64) {\n    // Easy to mix up from/to or amount/account\n}\n\ntransfer(123, 456, 100.0);  // Which is which?\n\n// ✅ Newtype for distinct types\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nstruct UserId(u32);\n\n#[derive(Debug, Clone, Copy)]\nstruct Amount(f64);\n\nfn transfer(from: UserId, to: UserId, amount: Amount) {\n    println!(\"Transfer {:?} from {:?} to {:?}\", amount, from, to);\n}\n\ntransfer(UserId(123), UserId(456), Amount(100.0));\n// transfer(UserId(123), Amount(100.0), UserId(456));  // ❌ Compile error!\n\n// ✅ Add methods to newtypes\nimpl Amount {\n    fn new(value: f64) -> Result<Self, &'static str> {\n        if value < 0.0 {\n            Err(\"Amount cannot be negative\")\n        } else {\n            Ok(Amount(value))\n        }\n    }\n    \n    fn value(&self) -> f64 {\n        self.0\n    }\n}\n\n// ✅ Implement traits for newtypes\nuse std::fmt;\n\nimpl fmt::Display for Amount {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"${:.2}\", self.0)\n    }\n}\n\nprintln!(\"{}\", Amount(123.456));  // \"$123.46\"\n\n// ✅ Prevent unit confusion\nstruct Meters(f64);\nstruct Kilometers(f64);\n\nimpl From<Kilometers> for Meters {\n    fn from(km: Kilometers) -> Self {\n        Meters(km.0 * 1000.0)\n    }\n}\n\nlet distance_km = Kilometers(5.0);\nlet distance_m: Meters = distance_km.into();\n\n// ✅ Email validation\nstruct Email(String);\n\nimpl Email {\n    fn new(s: String) -> Result<Self, &'static str> {\n        if s.contains('@') {\n            Ok(Email(s))\n        } else {\n            Err(\"Invalid email\")\n        }\n    }\n}\n```\n\nNewtype benefits:\n1. Compile-time type safety\n2. Prevents mixing incompatible values\n3. Encapsulates validation\n4. Zero runtime cost"}]}
{"messages":[{"role":"user","content":"Write Rust using turbofish for explicit type annotations"},{"role":"assistant","content":"Turbofish syntax for type disambiguation:\n\n```rust\n// ❌ Type inference fails\nlet numbers = vec![\"1\", \"2\", \"3\"];\nlet parsed = numbers.iter().map(|s| s.parse()).collect();\n// ❌ Error: can't infer type\n\n// ✅ Turbofish on collect\nlet parsed: Vec<i32> = numbers.iter()\n    .map(|s| s.parse().unwrap())\n    .collect();\n\n// ✅ Or use turbofish\nlet parsed = numbers.iter()\n    .map(|s| s.parse::<i32>().unwrap())\n    .collect::<Vec<_>>();\n\n// ✅ Turbofish for generic functions\nfn parse_value<T: std::str::FromStr>(s: &str) -> Option<T> {\n    s.parse().ok()\n}\n\nlet num = parse_value::<i32>(\"42\");      // Some(42)\nlet float = parse_value::<f64>(\"3.14\");  // Some(3.14)\n\n// ✅ Turbofish with Option/Result\nlet value: Option<i32> = Some(\"42\".parse().unwrap());\n// Or explicitly:\nlet value = \"42\".parse::<i32>().ok();\n\n// ✅ Turbofish for HashMap\nuse std::collections::HashMap;\n\nlet map = HashMap::<String, i32>::new();\n// Or let inference work:\nlet mut map = HashMap::new();\nmap.insert(String::from(\"key\"), 42);  // Infers types\n\n// ✅ Turbofish with iterators\nlet sum = (1..=10)\n    .filter(|&n| n % 2 == 0)\n    .sum::<i32>();\n\nlet product = vec![2, 3, 4]\n    .iter()\n    .product::<i32>();\n\n// ✅ Default trait with turbofish\nlet default_vec = Vec::<i32>::default();  // Empty vec\nlet default_str = String::default();       // Empty string\n\n// ✅ Explicit generic in struct instantiation\nstruct Container<T> {\n    value: T,\n}\n\nlet container = Container::<i32> { value: 42 };\n```\n\nTurbofish usage:\n1. Disambiguate generic types\n2. When inference can't determine type\n3. parse::<T>() for conversions\n4. collect::<Vec<_>>() for collections"}]}
{"messages":[{"role":"user","content":"Show Rust using if let and while let for pattern matching"},{"role":"assistant","content":"if let and while let for concise matching:\n\n```rust\n// ❌ Verbose match for single variant\nlet opt = Some(42);\nmatch opt {\n    Some(n) => println!(\"Got: {}\", n),\n    None => {},\n}\n\n// ✅ Use if let\nif let Some(n) = opt {\n    println!(\"Got: {}\", n);\n}\n\n// ✅ if let with else\nif let Some(user) = find_user(id) {\n    greet(&user);\n} else {\n    println!(\"User not found\");\n}\n\n// ❌ Loop with match for queue processing\nloop {\n    match queue.pop() {\n        Some(item) => process(item),\n        None => break,\n    }\n}\n\n// ✅ Use while let\nwhile let Some(item) = queue.pop() {\n    process(item);\n}\n\n// ✅ while let with iterators\nlet mut iter = vec![1, 2, 3].into_iter();\nwhile let Some(n) = iter.next() {\n    println!(\"{}\", n);\n}\n\n// ✅ Destructure in if let\nlet result: Result<i32, Error> = Ok(42);\nif let Ok(value) = result {\n    println!(\"Success: {}\", value);\n}\n\n// ✅ Multiple patterns with |\nlet value = Some(5);\nif let Some(n @ 1..=10) = value {\n    println!(\"Small number: {}\", n);\n}\n\n// ✅ Guard clauses with if let\nif let Some(user) = find_user(id) && user.is_active() {\n    login(user);\n}\n\n// ✅ Nested if let (be careful)\nif let Some(config) = load_config() {\n    if let Some(db) = config.database {\n        connect(&db);\n    }\n}\n\n// ✅ Better: use and_then\nload_config()\n    .and_then(|c| c.database)\n    .map(|db| connect(&db));\n```\n\nif let / while let guidelines:\n1. Use for single variant matching\n2. while let for consuming iterators\n3. Cleaner than match with one arm\n4. Combine with guards for conditions"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust using matches! macro for boolean checks"},{"role":"assistant","content":"matches! macro for pattern testing:\n\n```rust\n// ❌ Verbose match for boolean\nenum Status {\n    Active,\n    Pending,\n    Inactive,\n}\n\nlet status = Status::Active;\nlet is_active = match status {\n    Status::Active => true,\n    _ => false,\n};\n\n// ✅ Use matches! macro\nlet is_active = matches!(status, Status::Active);\n\n// ✅ Multiple patterns\nlet is_actionable = matches!(status, Status::Active | Status::Pending);\n\n// ✅ With guards\nlet value = Some(42);\nlet is_large = matches!(value, Some(n) if n > 100);\n\n// ✅ Range patterns\nlet score = 85;\nlet passed = matches!(score, 60..=100);\n\n// ✅ Destructuring in matches!\n#[derive(Debug)]\nstruct Point { x: i32, y: i32 }\n\nlet point = Point { x: 0, y: 0 };\nlet is_origin = matches!(point, Point { x: 0, y: 0 });\n\n// ✅ Option/Result checks\nlet result: Result<i32, Error> = Ok(42);\nlet is_ok = matches!(result, Ok(_));\nlet is_err = matches!(result, Err(_));\n\n// ✅ Use in filter\nlet numbers = vec![Some(1), None, Some(3), None];\nlet has_values: Vec<_> = numbers.into_iter()\n    .filter(|opt| matches!(opt, Some(_)))\n    .collect();\n\n// ✅ Assert in tests\n#[test]\nfn test_status() {\n    let status = get_status();\n    assert!(matches!(status, Status::Active));\n}\n\n// ✅ Enum variant with data\nenum Message {\n    Text(String),\n    Number(i32),\n}\n\nlet msg = Message::Text(String::from(\"hello\"));\nlet is_text = matches!(msg, Message::Text(_));\nlet is_hello = matches!(msg, Message::Text(s) if s == \"hello\");\n```\n\nmatches! benefits:\n1. Cleaner than match for booleans\n2. Supports full pattern syntax\n3. Works with guards\n4. Great for filters and assertions"}]}
{"messages":[{"role":"user","content":"Show Rust using ? operator for error propagation"},{"role":"assistant","content":"? operator for concise error handling:\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\n// ❌ Manual error propagation\nfn read_file(path: &str) -> io::Result<String> {\n    let mut file = match File::open(path) {\n        Ok(f) => f,\n        Err(e) => return Err(e),\n    };\n    \n    let mut contents = String::new();\n    match file.read_to_string(&mut contents) {\n        Ok(_) => Ok(contents),\n        Err(e) => Err(e),\n    }\n}\n\n// ✅ Use ? operator\nfn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}\n\n// ✅ Even more concise\nfn read_file(path: &str) -> io::Result<String> {\n    let mut contents = String::new();\n    File::open(path)?.read_to_string(&mut contents)?;\n    Ok(contents)\n}\n\n// ✅ Chain multiple operations\nfn parse_config(path: &str) -> Result<Config, Box<dyn Error>> {\n    let contents = fs::read_to_string(path)?;\n    let config: Config = serde_json::from_str(&contents)?;\n    Ok(config)\n}\n\n// ✅ Use in Option contexts\nfn first_char(s: &str) -> Option<char> {\n    let first = s.chars().next()?;  // Early return on None\n    Some(first)\n}\n\n// ✅ Convert Option to Result with ok_or\nfn get_env_var(key: &str) -> Result<String, Error> {\n    std::env::var(key)\n        .ok()\n        .ok_or(Error::MissingEnv)?  // Convert to Result\n}\n\n// ✅ Use in main for quick scripts\nfn main() -> Result<(), Box<dyn Error>> {\n    let config = load_config(\"config.json\")?;\n    let db = connect_db(&config.db_url)?;\n    run_migrations(&db)?;\n    Ok(())\n}\n\n// ⚠️ Don't mix Result and Option without conversion\n// fn bad() -> Result<String, Error> {\n//     let val = some_option?;  // ❌ Won't compile\n//     Ok(val)\n// }\n\n// ✅ Convert Option to Result first\nfn good() -> Result<String, Error> {\n    let val = some_option.ok_or(Error::NotFound)?;\n    Ok(val)\n}\n```\n\n? operator guidelines:\n1. Use in functions returning Result/Option\n2. Propagates errors automatically\n3. Works with Option too\n4. Can use in main() for scripts"}]}
{"messages":[{"role":"user","content":"Write Rust using AsRef/AsMut for flexible APIs"},{"role":"assistant","content":"AsRef and AsMut for generic parameters:\n\n```rust\nuse std::path::Path;\nuse std::fs::File;\n\n// ❌ Rigid API requiring specific type\nfn open_file(path: &Path) -> io::Result<File> {\n    File::open(path)\n}\n\nlet file = open_file(Path::new(\"file.txt\"));  // Verbose\n\n// ✅ Generic with AsRef<Path>\nfn open_file<P: AsRef<Path>>(path: P) -> io::Result<File> {\n    File::open(path.as_ref())\n}\n\nopen_file(\"file.txt\");              // &str\nopen_file(String::from(\"file.txt\")); // String\nopen_file(Path::new(\"file.txt\"));   // &Path\nopen_file(PathBuf::from(\"file.txt\")); // PathBuf\n\n// ✅ AsRef<str> for string-like types\nfn count_words<S: AsRef<str>>(text: S) -> usize {\n    text.as_ref().split_whitespace().count()\n}\n\ncount_words(\"hello world\");         // &str\ncount_words(String::from(\"test\"));  // String\n\n// ✅ AsRef<[T]> for slice-like types\nfn sum<S: AsRef<[i32]>>(numbers: S) -> i32 {\n    numbers.as_ref().iter().sum()\n}\n\nsum(&[1, 2, 3]);           // &[i32]\nsum(vec![1, 2, 3]);        // Vec<i32>\n\n// ✅ AsMut for mutable references\nfn uppercase<S: AsMut<str>>(mut text: S) {\n    text.as_mut().make_ascii_uppercase();\n}\n\nlet mut s = String::from(\"hello\");\nuppercase(&mut s);\n\n// ✅ Implement AsRef for custom types\nstruct Email(String);\n\nimpl AsRef<str> for Email {\n    fn as_ref(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl AsRef<[u8]> for Email {\n    fn as_ref(&self) -> &[u8] {\n        self.0.as_bytes()\n    }\n}\n\nlet email = Email(String::from(\"user@example.com\"));\nlet s: &str = email.as_ref();\nlet bytes: &[u8] = email.as_ref();\n\n// ✅ Common in std library\nfs::read_to_string(\"file.txt\")?;  // Takes AsRef<Path>\nPath::new(\"dir\").join(\"file\");     // Takes AsRef<Path>\n```\n\nAsRef/AsMut benefits:\n1. Flexible function parameters\n2. Accepts multiple types\n3. Used extensively in std\n4. Zero-cost abstraction"}]}
{"messages":[{"role":"user","content":"Show Rust using Vec::with_capacity to avoid reallocations"},{"role":"assistant","content":"Pre-allocate with with_capacity:\n\n```rust\n// ❌ Multiple reallocations\nlet mut vec = Vec::new();\nfor i in 0..1000 {\n    vec.push(i);  // Reallocates multiple times\n}\n\n// ✅ Pre-allocate capacity\nlet mut vec = Vec::with_capacity(1000);\nfor i in 0..1000 {\n    vec.push(i);  // No reallocations\n}\n\n// ✅ Use size_hint from iterator\nlet numbers: Vec<_> = (0..100).collect();\n// collect() uses size_hint automatically\n\n// ✅ HashMap with capacity\nuse std::collections::HashMap;\n\nlet mut map = HashMap::with_capacity(100);\nfor i in 0..100 {\n    map.insert(i, i * 2);\n}\n\n// ✅ String with capacity\nlet mut s = String::with_capacity(100);\nfor _ in 0..10 {\n    s.push_str(\"hello\");  // No reallocation\n}\n\n// ✅ Collect with pre-allocated size\nfn process_items(items: &[i32]) -> Vec<String> {\n    let mut result = Vec::with_capacity(items.len());\n    for &item in items {\n        result.push(item.to_string());\n    }\n    result\n}\n\n// ✅ Better: use iterator\nfn process_items(items: &[i32]) -> Vec<String> {\n    items.iter()\n        .map(|&n| n.to_string())\n        .collect()  // Uses size_hint\n}\n\n// ✅ Check capacity vs length\nlet mut vec = Vec::with_capacity(10);\nvec.push(1);\nassert_eq!(vec.len(), 1);       // Current length\nassert_eq!(vec.capacity(), 10); // Allocated capacity\n\n// ✅ Reserve additional space\nlet mut vec = vec![1, 2, 3];\nvec.reserve(100);  // Ensure space for 100 more elements\n\n// ✅ Shrink to fit\nlet mut vec = Vec::with_capacity(100);\nvec.push(1);\nvec.shrink_to_fit();  // Free unused capacity\nassert_eq!(vec.capacity(), vec.len());\n```\n\nwith_capacity benefits:\n1. Avoid reallocations\n2. Better performance\n3. Predictable memory usage\n4. Use when size is known"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust using Cow for clone-on-write"},{"role":"assistant","content":"Cow for efficient conditional cloning:\n\n```rust\nuse std::borrow::Cow;\n\n// ❌ Always clones even when not needed\nfn process(s: String) -> String {\n    if s.contains(\"bad\") {\n        s.replace(\"bad\", \"good\")\n    } else {\n        s  // Unnecessary clone if passed &str\n    }\n}\n\n// ✅ Use Cow to avoid unnecessary clones\nfn process(s: &str) -> Cow<str> {\n    if s.contains(\"bad\") {\n        Cow::Owned(s.replace(\"bad\", \"good\"))  // Clone only when needed\n    } else {\n        Cow::Borrowed(s)  // No allocation\n    }\n}\n\nlet result1 = process(\"hello\");      // Borrowed, no clone\nlet result2 = process(\"bad word\");   // Owned, cloned\n\n// ✅ Use to_mut for conditional modification\nfn ensure_prefix(s: &str, prefix: &str) -> Cow<str> {\n    if s.starts_with(prefix) {\n        Cow::Borrowed(s)\n    } else {\n        Cow::Owned(format!(\"{}{}\", prefix, s))\n    }\n}\n\n// ✅ Cow with slices\nfn remove_duplicates(nums: &[i32]) -> Cow<[i32]> {\n    let mut seen = std::collections::HashSet::new();\n    let has_dupes = nums.iter().any(|&n| !seen.insert(n));\n    \n    if has_dupes {\n        let mut unique: Vec<_> = nums.to_vec();\n        unique.dedup();\n        Cow::Owned(unique)\n    } else {\n        Cow::Borrowed(nums)\n    }\n}\n\n// ✅ Into trait for ergonomics\nfn normalize(s: impl Into<Cow<'static, str>>) -> Cow<'static, str> {\n    let s = s.into();\n    if s.chars().all(|c| c.is_lowercase()) {\n        s\n    } else {\n        Cow::Owned(s.to_lowercase())\n    }\n}\n\nnormalize(\"hello\");              // &str -> Borrowed\nnormalize(String::from(\"HELLO\")); // String -> Owned\n\n// ✅ to_mut for in-place modification\nlet mut cow: Cow<str> = Cow::Borrowed(\"hello\");\ncow.to_mut().push_str(\" world\");  // Converts to Owned\nassert!(matches!(cow, Cow::Owned(_)));\n\n// ✅ Common in APIs for flexibility\nuse std::path::Path;\n\nfn add_extension<'a>(path: &'a Path, ext: &str) -> Cow<'a, Path> {\n    if path.extension().is_some() {\n        Cow::Borrowed(path)\n    } else {\n        let mut buf = path.to_path_buf();\n        buf.set_extension(ext);\n        Cow::Owned(buf)\n    }\n}\n```\n\nCow benefits:\n1. Clone only when necessary\n2. Optimize for read-heavy workloads\n3. Flexible APIs (accept borrowed or owned)\n4. Common in std library"}]}
{"messages":[{"role":"user","content":"Show Rust using From/Into for type conversions"},{"role":"assistant","content":"From/Into traits for idiomatic conversions:\n\n```rust\n// ✅ Implement From (Into is automatic)\nstruct UserId(u32);\n\nimpl From<u32> for UserId {\n    fn from(id: u32) -> Self {\n        UserId(id)\n    }\n}\n\nlet id: UserId = 42.into();     // Uses Into\nlet id = UserId::from(42);      // Uses From\n\n// ✅ From for error conversions\nuse std::io;\nuse std::num::ParseIntError;\n\n#[derive(Debug)]\nenum MyError {\n    Io(io::Error),\n    Parse(ParseIntError),\n}\n\nimpl From<io::Error> for MyError {\n    fn from(err: io::Error) -> Self {\n        MyError::Io(err)\n    }\n}\n\nimpl From<ParseIntError> for MyError {\n    fn from(err: ParseIntError) -> Self {\n        MyError::Parse(err)\n    }\n}\n\n// ✅ Now ? works automatically\nfn read_number(path: &str) -> Result<i32, MyError> {\n    let contents = fs::read_to_string(path)?;  // io::Error -> MyError\n    let number = contents.trim().parse()?;      // ParseIntError -> MyError\n    Ok(number)\n}\n\n// ✅ From for string conversions\nstruct Name(String);\n\nimpl From<&str> for Name {\n    fn from(s: &str) -> Self {\n        Name(s.to_string())\n    }\n}\n\nimpl From<String> for Name {\n    fn from(s: String) -> Self {\n        Name(s)\n    }\n}\n\nlet name1 = Name::from(\"Alice\");\nlet name2 = Name::from(String::from(\"Bob\"));\n\n// ✅ From for infallible conversions only\n// For fallible conversions, use TryFrom:\nuse std::convert::TryFrom;\n\nstruct EvenNumber(i32);\n\nimpl TryFrom<i32> for EvenNumber {\n    type Error = &'static str;\n    \n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(\"Not an even number\")\n        }\n    }\n}\n\nlet even = EvenNumber::try_from(4)?;  // Ok\nlet odd = EvenNumber::try_from(3)?;   // Err\n\n// ✅ Generic functions with Into\nfn set_name(name: impl Into<String>) {\n    let name: String = name.into();\n    println!(\"Name: {}\", name);\n}\n\nset_name(\"Alice\");              // &str\nset_name(String::from(\"Bob\"));  // String\n```\n\nFrom/Into guidelines:\n1. Implement From, get Into free\n2. Use for infallible conversions\n3. TryFrom for fallible conversions\n4. Works great with ? operator"}]}
{"messages":[{"role":"user","content":"Write Rust using Entry API for HashMap operations"},{"role":"assistant","content":"Entry API for efficient HashMap updates:\n\n```rust\nuse std::collections::HashMap;\n\n// ❌ Multiple lookups\nlet mut map = HashMap::new();\nif map.contains_key(&key) {\n    let val = map.get_mut(&key).unwrap();\n    *val += 1;\n} else {\n    map.insert(key, 1);\n}\n\n// ✅ Use Entry API (single lookup)\nlet mut map = HashMap::new();\n*map.entry(key).or_insert(0) += 1;\n\n// ✅ or_insert for default values\nlet mut scores = HashMap::new();\nscores.entry(\"Alice\").or_insert(0);\n\n// ✅ or_insert_with for lazy initialization\nlet mut cache = HashMap::new();\ncache.entry(key).or_insert_with(|| expensive_computation());\n\n// ✅ and_modify for conditional updates\nlet mut map = HashMap::new();\nmap.entry(\"key\")\n    .and_modify(|v| *v += 1)\n    .or_insert(1);\n\n// ✅ Count word occurrences\nfn count_words(text: &str) -> HashMap<&str, usize> {\n    let mut counts = HashMap::new();\n    for word in text.split_whitespace() {\n        *counts.entry(word).or_insert(0) += 1;\n    }\n    counts\n}\n\n// ✅ Group by key\nfn group_by_first_letter(words: Vec<String>) -> HashMap<char, Vec<String>> {\n    let mut groups = HashMap::new();\n    for word in words {\n        let first = word.chars().next().unwrap();\n        groups.entry(first)\n            .or_insert_with(Vec::new)\n            .push(word);\n    }\n    groups\n}\n\n// ✅ Merge maps\nfn merge_maps(map1: HashMap<String, i32>, map2: HashMap<String, i32>) -> HashMap<String, i32> {\n    let mut result = map1;\n    for (key, value) in map2 {\n        *result.entry(key).or_insert(0) += value;\n    }\n    result\n}\n\n// ✅ Pattern match on Entry\nuse std::collections::hash_map::Entry;\n\nmatch map.entry(key) {\n    Entry::Occupied(mut e) => {\n        println!(\"Existing: {}\", e.get());\n        e.insert(new_value);\n    }\n    Entry::Vacant(e) => {\n        println!(\"Inserting new\");\n        e.insert(default_value);\n    }\n}\n```\n\nEntry API benefits:\n1. Single lookup (not two)\n2. More efficient\n3. Cleaner code\n4. Lazy initialization with or_insert_with"}]}
{"messages":[{"role":"user","content":"Show Rust using dbg! for quick debugging"},{"role":"assistant","content":"dbg! macro for development debugging:\n\n```rust\n// ❌ Manual println debugging\nlet result = compute();\nprintln!(\"result = {:?}\", result);\nprocess(result);\n\n// ✅ Use dbg! (prints expression and value)\nprocess(dbg!(compute()));\n// Prints: [src/main.rs:42] compute() = 42\n\n// ✅ dbg! returns the value\nlet x = dbg!(5 * 3);  // Prints and assigns 15 to x\nassert_eq!(x, 15);\n\n// ✅ Debug intermediate values in chains\nlet result = vec![1, 2, 3]\n    .iter()\n    .map(|x| dbg!(x * 2))     // Prints each multiplication\n    .filter(|&x| dbg!(x > 3)) // Prints each comparison\n    .collect::<Vec<_>>();\n\n// ✅ Multiple values\ndbg!(x, y, z);\n// Prints:\n// [src/main.rs:10] x = 1\n// [src/main.rs:10] y = 2\n// [src/main.rs:10] z = 3\n\n// ✅ Ownership-friendly (returns value)\nlet s = String::from(\"hello\");\nlet s = dbg!(s);  // ✅ s is still usable\nprintln!(\"{}\", s);\n\n// ✅ Works with references\nlet vec = vec![1, 2, 3];\ndbg!(&vec);  // Borrows, doesn't move\ndbg!(vec);   // Moves if not Copy\n\n// ✅ Complex expressions\ndbg!({\n    let x = 5;\n    let y = 10;\n    x + y\n});\n\n// ✅ Conditional compilation\n#[cfg(debug_assertions)]\ndbg!(expensive_operation());\n\n#[cfg(not(debug_assertions))]\nexpensive_operation();\n\n// ⚠️ Remove dbg! before release\n// Use in development only\n// Consider using log crate for production\n```\n\ndbg! benefits:\n1. Prints file, line, expression, and value\n2. Returns the value (composable)\n3. Works with ownership\n4. Great for quick debugging"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust using const fn for compile-time evaluation"},{"role":"assistant","content":"const fn for compile-time constants:\n\n```rust\n// ✅ const fn for compile-time computation\nconst fn square(n: u32) -> u32 {\n    n * n\n}\n\nconst FOUR_SQUARED: u32 = square(4);  // Computed at compile time\n\n// ✅ Use in array sizes\nconst SIZE: usize = square(10) as usize;\nlet array = [0; SIZE];  // [0; 100]\n\n// ✅ const fn for constructors\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    const fn new(x: i32, y: i32) -> Self {\n        Point { x, y }\n    }\n    \n    const fn origin() -> Self {\n        Point { x: 0, y: 0 }\n    }\n}\n\nconst ORIGIN: Point = Point::origin();\nconst CENTER: Point = Point::new(50, 50);\n\n// ✅ const fn with conditionals\nconst fn max(a: u32, b: u32) -> u32 {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\nconst MAX_SIZE: u32 = max(100, 200);  // 200\n\n// ✅ const fn with loops\nconst fn factorial(n: u32) -> u32 {\n    let mut result = 1;\n    let mut i = 1;\n    while i <= n {\n        result *= i;\n        i += 1;\n    }\n    result\n}\n\nconst FACT_5: u32 = factorial(5);  // 120 at compile time\n\n// ⚠️ Limitations: can't allocate or use non-const functions\n// This won't work:\n// const fn to_string(n: i32) -> String {\n//     format!(\"{}\", n)  // ❌ Can't allocate in const fn\n// }\n\n// ✅ Use const for validation\nconst fn validate_range(n: u32) -> u32 {\n    assert!(n <= 100, \"Value too large\");\n    n\n}\n\nconst VALID: u32 = validate_range(50);   // ✅ Compiles\n// const INVALID: u32 = validate_range(200); // ❌ Compile error\n\n// ✅ Generic const fn\nconst fn identity<T>(value: T) -> T {\n    value\n}\n\nconst X: i32 = identity(42);\n```\n\nconst fn benefits:\n1. Computed at compile time\n2. Zero runtime cost\n3. Can use in const contexts\n4. Great for array sizes, configuration"}]}
{"messages":[{"role":"user","content":"Show Rust using panic! vs Result for error handling"},{"role":"assistant","content":"Choose Result over panic for recoverable errors:\n\n```rust\n// ❌ Panic for recoverable errors\nfn divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!(\"Division by zero!\");  // Crashes program\n    }\n    a / b\n}\n\n// ✅ Return Result for recoverable errors\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from(\"Division by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\nmatch divide(10, 0) {\n    Ok(result) => println!(\"Result: {}\", result),\n    Err(e) => eprintln!(\"Error: {}\", e),  // Handle gracefully\n}\n\n// ✅ Use panic! only for programming errors\nfn get_item(index: usize) -> &Item {\n    assert!(index < self.items.len(), \"Index out of bounds\");\n    &self.items[index]\n}\n\n// ✅ Custom error types\n#[derive(Debug)]\nenum MathError {\n    DivisionByZero,\n    Overflow,\n}\n\nfn divide(a: i32, b: i32) -> Result<i32, MathError> {\n    if b == 0 {\n        Err(MathError::DivisionByZero)\n    } else {\n        a.checked_div(b).ok_or(MathError::Overflow)\n    }\n}\n\n// ✅ unwrap() and expect() for prototypes/tests\n#[test]\nfn test_config() {\n    let config = load_config().expect(\"Failed to load test config\");\n    assert_eq!(config.port, 8080);\n}\n\n// ❌ Don't use unwrap() in production\nfn bad_production_code() {\n    let file = File::open(\"config.json\").unwrap();  // ❌ Can crash\n}\n\n// ✅ Handle errors properly\nfn good_production_code() -> Result<(), Error> {\n    let file = File::open(\"config.json\")?;  // ✅ Propagate error\n    Ok(())\n}\n\n// ✅ Use panic! for invariants\nfn new_positive(n: i32) -> Positive {\n    assert!(n > 0, \"Value must be positive\");  // Contract violation\n    Positive(n)\n}\n\n// ✅ unreachable! for impossible states\nmatch value {\n    Some(x) => process(x),\n    None => unreachable!(\"Value guaranteed to be Some\"),\n}\n```\n\npanic vs Result guidelines:\n1. Result for recoverable errors (I/O, parsing, etc.)\n2. panic! for invariants and programming bugs\n3. Never panic! in library code\n4. unwrap/expect only in tests/prototypes"}]}
{"messages":[{"role":"user","content":"Write Rust using pattern matching with @ bindings"},{"role":"assistant","content":"@ bindings for capturing matched values:\n\n```rust\n// ✅ Capture value while matching pattern\nmatch age {\n    n @ 0..=17 => println!(\"Minor: {}\", n),\n    n @ 18..=64 => println!(\"Adult: {}\", n),\n    n @ 65.. => println!(\"Senior: {}\", n),\n}\n\n// ❌ Without @ binding (need to repeat)\nmatch age {\n    0..=17 => println!(\"Minor: {}\", age),  // Using outer variable\n    18..=64 => println!(\"Adult: {}\", age),\n    65.. => println!(\"Senior: {}\", age),\n}\n\n// ✅ Capture enum variants with data\nenum Message {\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(u8, u8, u8),\n}\n\nmatch msg {\n    msg @ Message::Move { .. } => {\n        // Have access to entire msg and can match fields\n        process_move(&msg);\n    }\n    Message::Write(ref text) => println!(\"{}\", text),\n    Message::ChangeColor(r, g, b) => set_color(r, g, b),\n}\n\n// ✅ Nested @ patterns\nmatch point {\n    Point { x: x @ 0..=5, y: y @ 0..=5 } => {\n        println!(\"Point in quadrant: ({}, {})\", x, y);\n    }\n    _ => println!(\"Out of range\"),\n}\n\n// ✅ @ with guards\nmatch value {\n    n @ 1..=10 if n % 2 == 0 => println!(\"Even in range: {}\", n),\n    n @ 1..=10 => println!(\"Odd in range: {}\", n),\n    _ => println!(\"Out of range\"),\n}\n\n// ✅ Capture Option while checking\nmatch config.timeout {\n    Some(t @ 1..=60) => set_timeout(t),\n    Some(t) => eprintln!(\"Invalid timeout: {}\", t),\n    None => use_default_timeout(),\n}\n\n// ✅ Destructure and capture\nenum Either<L, R> {\n    Left(L),\n    Right(R),\n}\n\nmatch result {\n    left @ Either::Left(_) => {\n        log(\"Got left\");\n        process_left(left);\n    }\n    Either::Right(value) => process_right(value),\n}\n```\n\n@ binding benefits:\n1. Capture matched value\n2. Use in pattern and body\n3. Avoid repeating expressions\n4. Works with ranges and guards"}]}
{"messages":[{"role":"user","content":"Show Rust using std::mem::take to move from mutable references"},{"role":"assistant","content":"std::mem::take to replace with default:\n\n```rust\nuse std::mem;\n\n// ❌ Can't move out of mutable reference\nfn process(data: &mut Vec<String>) {\n    // let owned = *data;  // ❌ Can't move out\n}\n\n// ✅ Use mem::take to replace with default\nfn process(data: &mut Vec<String>) {\n    let owned = mem::take(data);  // ✅ Replaces with Vec::new()\n    // data is now empty, owned has the values\n    for item in owned {\n        println!(\"{}\", item);\n    }\n}\n\n// ✅ Process and replace Option\nfn take_message(msg: &mut Option<String>) -> Option<String> {\n    mem::take(msg)  // Replaces with None\n}\n\nlet mut msg = Some(String::from(\"hello\"));\nlet taken = take_message(&mut msg);\nassert!(msg.is_none());\n\n// ✅ Swap with temporary value\nstruct State {\n    data: Vec<i32>,\n}\n\nimpl State {\n    fn process(&mut self) {\n        let data = mem::take(&mut self.data);  // Empty self.data\n        let processed = data.into_iter()\n            .map(|x| x * 2)\n            .collect();\n        self.data = processed;  // Restore\n    }\n}\n\n// ✅ mem::replace for non-default values\nlet mut value = 42;\nlet old = mem::replace(&mut value, 100);\nassert_eq!(old, 42);\nassert_eq!(value, 100);\n\n// ✅ mem::swap to exchange values\nlet mut x = 5;\nlet mut y = 10;\nmem::swap(&mut x, &mut y);\nassert_eq!(x, 10);\nassert_eq!(y, 5);\n\n// ✅ Take from struct field\nstruct Cache {\n    data: Option<Vec<u8>>,\n}\n\nimpl Cache {\n    fn consume(&mut self) -> Option<Vec<u8>> {\n        mem::take(&mut self.data)  // Leaves None\n    }\n}\n\n// ✅ Common in Drop implementations\nimpl Drop for MyStruct {\n    fn drop(&mut self) {\n        let data = mem::take(&mut self.data);\n        cleanup(data);\n    }\n}\n```\n\nmem::take/replace benefits:\n1. Move from &mut reference\n2. Replace with default value\n3. No Clone needed\n4. Common in state management"}]}
{"messages":[{"role":"user","content":"Demonstrate Rust using Default trait for initialization"},{"role":"assistant","content":"Default trait for clean initialization:\n\n```rust\n// ✅ Derive Default for simple cases\n#[derive(Debug, Default)]\nstruct Config {\n    host: String,      // Default: \"\"\n    port: u16,         // Default: 0\n    debug: bool,       // Default: false\n}\n\nlet config = Config::default();\n\n// ✅ Custom Default implementation\nimpl Default for Config {\n    fn default() -> Self {\n        Self {\n            host: String::from(\"localhost\"),\n            port: 8080,\n            debug: false,\n        }\n    }\n}\n\n// ✅ Use ..Default::default() for partial init\nlet config = Config {\n    port: 9000,\n    ..Default::default()  // Use defaults for rest\n};\n\n// ✅ Default in function parameters\nfn create_server(config: Option<Config>) -> Server {\n    let config = config.unwrap_or_default();\n    Server::new(config)\n}\n\n// ✅ Default for generic types\nfn process<T: Default>() -> T {\n    T::default()\n}\n\nlet vec: Vec<i32> = process();      // Empty vec\nlet string: String = process();     // Empty string\nlet num: i32 = process();           // 0\n\n// ✅ Default for builder pattern\n#[derive(Default)]\nstruct ServerBuilder {\n    host: Option<String>,\n    port: Option<u16>,\n}\n\nimpl ServerBuilder {\n    fn new() -> Self {\n        Self::default()\n    }\n    \n    fn host(mut self, host: impl Into<String>) -> Self {\n        self.host = Some(host.into());\n        self\n    }\n    \n    fn port(mut self, port: u16) -> Self {\n        self.port = Some(port);\n        self\n    }\n    \n    fn build(self) -> Server {\n        Server {\n            host: self.host.unwrap_or_else(|| String::from(\"localhost\")),\n            port: self.port.unwrap_or(8080),\n        }\n    }\n}\n\n// ✅ mem::take uses Default\nlet mut vec = vec![1, 2, 3];\nlet taken = std::mem::take(&mut vec);  // vec is now empty (default)\nassert!(vec.is_empty());\n```\n\nDefault trait benefits:\n1. Standard initialization pattern\n2. Works with unwrap_or_default()\n3. Enables ..Default::default() syntax\n4. Used by std library extensively"}]}
{"messages":[{"role":"user","content":"Show Rust using non-lexical lifetimes (NLL) patterns"},{"role":"assistant","content":"Non-lexical lifetimes for flexible borrowing:\n\n```rust\n// ❌ Pre-NLL: borrow lasts entire scope\n// This would error in old Rust:\n// fn process(data: &mut Vec<i32>) {\n//     let first = &data[0];  // Immutable borrow\n//     data.push(5);          // ❌ Mutable borrow while first exists\n//     println!(\"{}\", first);\n// }\n\n// ✅ With NLL: borrow ends at last use\nfn process(data: &mut Vec<i32>) {\n    let first = &data[0];  // Immutable borrow\n    println!(\"{}\", first); // Last use of first\n    data.push(5);          // ✅ OK, first not used after\n}\n\n// ✅ Multiple non-overlapping borrows\nfn analyze(text: &mut String) {\n    let len = text.len();  // Immutable borrow\n    println!(\"Length: {}\", len);  // Last use\n    \n    text.push_str(\" more\");  // ✅ Mutable borrow OK\n}\n\n// ✅ Conditional returns\nfn find_or_insert<'a>(map: &'a mut HashMap<String, String>, key: &str) \n    -> &'a str \n{\n    if map.contains_key(key) {\n        return &map[key];  // Immutable borrow ends here in this branch\n    }\n    map.insert(key.to_string(), String::new());  // ✅ Mutable borrow OK\n    &map[key]\n}\n\n// ✅ Entry API leverages NLL\nlet mut map = HashMap::new();\nmatch map.entry(\"key\".to_string()) {\n    Entry::Occupied(e) => {\n        println!(\"{}\", e.get());  // Borrow ends\n    }\n    Entry::Vacant(e) => {\n        e.insert(String::from(\"value\"));  // ✅ OK\n    }\n}  // Borrow ends here, not at start of match\n\n// ✅ Early return pattern\nfn validate(data: &mut Data) -> Result<(), Error> {\n    if data.is_empty() {\n        return Err(Error::Empty);  // Borrow ends\n    }\n    data.process();  // ✅ Can mutate\n    Ok(())\n}\n\n// ✅ Loops with borrows\nlet mut vec = vec![1, 2, 3];\nfor i in 0..3 {\n    let item = &vec[i];  // Immutable borrow\n    println!(\"{}\", item);  // Last use\n    // Borrow ends here, can mutate in next iteration\n}\nvec.push(4);  // ✅ OK\n```\n\nNLL benefits:\n1. More flexible borrow checker\n2. Borrows end at last use\n3. Fewer lifetime annotations needed\n4. More intuitive error messages"}]}
{"messages":[{"role":"user","content":"Write TypeScript using discriminated unions instead of optional fields"},{"role":"assistant","content":"Discriminated unions for type safety:\n\n```typescript\n// ❌ Optional fields (hard to validate)\ninterface Response {\n  success: boolean;\n  data?: User;\n  error?: string;\n}\n\nfunction handleResponse(res: Response) {\n  if (res.success) {\n    console.log(res.data.name);  // ❌ data might be undefined\n  }\n}\n\n// ✅ Discriminated union\ntype Response =\n  | { success: true; data: User }\n  | { success: false; error: string };\n\nfunction handleResponse(res: Response) {\n  if (res.success) {\n    console.log(res.data.name);  // ✅ data guaranteed to exist\n  } else {\n    console.error(res.error);    // ✅ error guaranteed to exist\n  }\n}\n\n// ✅ Exhaustive checking with never\nfunction handleResponse(res: Response): string {\n  switch (res.success) {\n    case true:\n      return res.data.name;\n    case false:\n      return res.error;\n    default:\n      const _exhaustive: never = res;  // ✅ Compile error if not exhaustive\n      throw new Error('Unhandled case');\n  }\n}\n\n// ✅ Multiple states\ntype LoadingState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\nfunction render(state: LoadingState<User>) {\n  switch (state.status) {\n    case 'idle':\n      return 'Not started';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Hello ${state.data.name}`;  // ✅ Type-safe\n    case 'error':\n      return state.error.message;\n  }\n}\n\n// ✅ Event types\ntype Event =\n  | { type: 'click'; x: number; y: number }\n  | { type: 'keypress'; key: string }\n  | { type: 'focus'; element: HTMLElement };\n\nfunction handleEvent(event: Event) {\n  if (event.type === 'click') {\n    console.log(`Clicked at ${event.x}, ${event.y}`);\n  } else if (event.type === 'keypress') {\n    console.log(`Key pressed: ${event.key}`);\n  }\n}\n```\n\nDiscriminated union benefits:\n1. Type narrowing with discriminant\n2. Impossible states ruled out\n3. Exhaustive checking\n4. Better than optional fields"}]}
{"messages":[{"role":"user","content":"Show TypeScript using const assertions for literal types"},{"role":"assistant","content":"const assertions for precise types:\n\n```typescript\n// ❌ Without const assertion (widened types)\nconst config = {\n  env: 'production',  // Type: string\n  port: 8080,         // Type: number\n};\n\nconfig.env = 'anything';  // ✅ Allowed (too permissive)\n\n// ✅ With const assertion\nconst config = {\n  env: 'production',  // Type: \"production\"\n  port: 8080,         // Type: 8080\n} as const;\n\n// config.env = 'development';  // ❌ Error: can't assign to readonly\n\n// ✅ Tuple instead of array\nconst point = [10, 20];         // Type: number[]\nconst point = [10, 20] as const;  // Type: readonly [10, 20]\n\n// ✅ Literal types from array\nconst COLORS = ['red', 'green', 'blue'] as const;\ntype Color = typeof COLORS[number];  // 'red' | 'green' | 'blue'\n\nfunction setColor(color: Color) {\n  // Only accepts exact values\n}\n\nsetColor('red');     // ✅ OK\nsetColor('yellow');  // ❌ Error\n\n// ✅ Configuration with exact types\nconst API_CONFIG = {\n  endpoints: {\n    users: '/api/users',\n    posts: '/api/posts',\n  },\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n} as const;\n\ntype Endpoint = typeof API_CONFIG.endpoints[keyof typeof API_CONFIG.endpoints];\n// Type: \"/api/users\" | \"/api/posts\"\n\ntype Method = typeof API_CONFIG.methods[number];\n// Type: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\"\n\n// ✅ Enum alternative\nconst Status = {\n  Pending: 'pending',\n  Active: 'active',\n  Completed: 'completed',\n} as const;\n\ntype Status = typeof Status[keyof typeof Status];\n// Type: \"pending\" | \"active\" | \"completed\"\n\n// ✅ Object.entries with const\nconst obj = { a: 1, b: 2 } as const;\nfor (const [key, value] of Object.entries(obj)) {\n  // key is \"a\" | \"b\"\n  // value is 1 | 2\n}\n```\n\nconst assertion benefits:\n1. Literal types instead of widened\n2. Readonly properties\n3. Better type inference\n4. Type-safe configuration"}]}
{"messages":[{"role":"user","content":"Demonstrate TypeScript using template literal types"},{"role":"assistant","content":"Template literal types for string manipulation:\n\n```typescript\n// ✅ Combine literal types\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype Endpoint = '/users' | '/posts';\ntype Route = `${HttpMethod} ${Endpoint}`;\n// Type: \"GET /users\" | \"POST /users\" | ... (8 combinations)\n\n// ✅ Event names\ntype EventType = 'click' | 'focus' | 'blur';\ntype EventName = `on${Capitalize<EventType>}`;\n// Type: \"onClick\" | \"onFocus\" | \"onBlur\"\n\ninterface Events {\n  onClick: () => void;\n  onFocus: () => void;\n  onBlur: () => void;\n}\n\n// ✅ CSS properties\ntype CSSColor = 'red' | 'green' | 'blue';\ntype CSSProperty = `background-${CSSColor}` | `border-${CSSColor}`;\n// Type: \"background-red\" | \"background-green\" | ...\n\n// ✅ Type-safe selectors\ntype Selector<T extends string> = `#${T}` | `.${T}` | `[${T}]`;\n\nfunction querySelector<T extends string>(selector: Selector<T>) {\n  return document.querySelector(selector);\n}\n\nquerySelector('#id');      // ✅ OK\nquerySelector('.class');   // ✅ OK\nquerySelector('invalid');  // ❌ Error\n\n// ✅ Path parameters\ntype PathParam<T extends string> = T extends `${infer Start}/:${infer Param}/${infer Rest}`\n  ? { [K in Param | keyof PathParam<`/${Rest}`>]: string }\n  : T extends `${infer Start}/:${infer Param}`\n  ? { [K in Param]: string }\n  : {};\n\ntype UserPath = PathParam<'/users/:userId/posts/:postId'>;\n// Type: { userId: string; postId: string }\n\n// ✅ Intrinsic string manipulation\ntype Greeting = 'hello world';\ntype Loud = Uppercase<Greeting>;      // \"HELLO WORLD\"\ntype Quiet = Lowercase<Greeting>;     // \"hello world\"\ntype Title = Capitalize<Greeting>;    // \"Hello world\"\ntype Untitle = Uncapitalize<Greeting>; // \"hello world\"\n\n// ✅ Generate getters/setters\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n\ntype Setters<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype UserGetters = Getters<User>;\n// { getName: () => string; getAge: () => number }\n```\n\nTemplate literal type benefits:\n1. Type-safe string combinations\n2. Intrinsic string manipulations\n3. Generate related types\n4. Enforce naming conventions"}]}
{"messages":[{"role":"user","content":"Show TypeScript using ReturnType and Parameters utility types"},{"role":"assistant","content":"ReturnType and Parameters for function introspection:\n\n```typescript\n// ✅ Extract return type\nfunction createUser(name: string, age: number) {\n  return { name, age, id: Math.random() };\n}\n\ntype User = ReturnType<typeof createUser>;\n// Type: { name: string; age: number; id: number }\n\nconst user: User = createUser('Alice', 30);\n\n// ✅ Extract parameters\ntype CreateUserParams = Parameters<typeof createUser>;\n// Type: [name: string, age: number]\n\nfunction callCreateUser(...args: CreateUserParams) {\n  return createUser(...args);\n}\n\n// ✅ Async function return type\nasync function fetchData(url: string) {\n  const res = await fetch(url);\n  return res.json();\n}\n\ntype Data = Awaited<ReturnType<typeof fetchData>>;\n// Type: any (from json())\n\n// ✅ Generic function wrapper\nfunction logged<T extends (...args: any[]) => any>(fn: T) {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    console.log('Calling with', args);\n    return fn(...args);\n  };\n}\n\nconst loggedCreate = logged(createUser);\nconst user = loggedCreate('Bob', 25);  // ✅ Fully typed\n\n// ✅ Extract constructor parameters\nclass Database {\n  constructor(public host: string, public port: number) {}\n}\n\ntype DbParams = ConstructorParameters<typeof Database>;\n// Type: [host: string, port: number]\n\nfunction createDatabase(...args: DbParams) {\n  return new Database(...args);\n}\n\n// ✅ ThisParameterType\nfunction greet(this: User, greeting: string) {\n  return `${greeting}, ${this.name}`;\n}\n\ntype GreetThis = ThisParameterType<typeof greet>;\n// Type: User\n\n// ✅ OmitThisParameter\ntype GreetFn = OmitThisParameter<typeof greet>;\n// Type: (greeting: string) => string\n\nconst boundGreet: GreetFn = greet.bind({ name: 'Alice', age: 30 });\n\n// ✅ Infer types from library functions\ntype FetchParams = Parameters<typeof fetch>;\n// Type: [input: RequestInfo | URL, init?: RequestInit]\n\ntype FetchReturn = Awaited<ReturnType<typeof fetch>>;\n// Type: Response\n```\n\nUtility type benefits:\n1. Extract types from existing code\n2. Avoid type duplication\n3. Type-safe wrappers\n4. Library integration"}]}
{"messages":[{"role":"user","content":"Write TypeScript using branded types for nominal typing"},{"role":"assistant","content":"Branded types for compile-time safety:\n\n```typescript\n// ❌ Primitive obsession\nfunction transfer(from: string, to: string, amount: number) {\n  // Easy to mix up from/to\n}\n\ntransfer('123', '456', 100);  // Which is which?\n\n// ✅ Branded types\ntype UserId = string & { readonly __brand: 'UserId' };\ntype AccountId = string & { readonly __brand: 'AccountId' };\n\nfunction UserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction AccountId(id: string): AccountId {\n  return id as AccountId;\n}\n\nfunction transfer(from: UserId, to: UserId, amount: number) {\n  console.log(`Transfer ${amount} from ${from} to ${to}`);\n}\n\nconst user1 = UserId('123');\nconst user2 = UserId('456');\nconst account = AccountId('789');\n\ntransfer(user1, user2, 100);    // ✅ OK\n// transfer(user1, account, 100);  // ❌ Error: types incompatible\n\n// ✅ Validated brands\ntype Email = string & { readonly __brand: 'Email' };\n\nfunction Email(value: string): Email | null {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(value) ? (value as Email) : null;\n}\n\nfunction sendEmail(to: Email, subject: string) {\n  // to is guaranteed to be valid email format\n}\n\nconst email = Email('user@example.com');\nif (email) {\n  sendEmail(email, 'Hello');  // ✅ Type-safe\n}\n\n// ✅ Numeric brands\ntype PositiveNumber = number & { readonly __brand: 'Positive' };\n\nfunction PositiveNumber(n: number): PositiveNumber | null {\n  return n > 0 ? (n as PositiveNumber) : null;\n}\n\nfunction setQuantity(qty: PositiveNumber) {\n  // qty guaranteed > 0\n}\n\n// ✅ Opaque types (better encapsulation)\nclass UserId {\n  private readonly __brand!: 'UserId';\n  private constructor(private readonly value: string) {}\n  \n  static create(id: string): UserId {\n    if (!id) throw new Error('Invalid user ID');\n    return new UserId(id);\n  }\n  \n  toString(): string {\n    return this.value;\n  }\n}\n\nconst id = UserId.create('123');\n// Can't create UserId without validation\n```\n\nBranded type benefits:\n1. Compile-time nominal typing\n2. Prevent mixing incompatible IDs\n3. Encapsulate validation\n4. Zero runtime cost"}]}
{"messages":[{"role":"user","content":"Show TypeScript using mapped types for transformations"},{"role":"assistant","content":"Mapped types to transform object shapes:\n\n```typescript\n// ✅ Make all properties optional\ntype User = {\n  name: string;\n  email: string;\n  age: number;\n};\n\ntype PartialUser = Partial<User>;\n// { name?: string; email?: string; age?: number }\n\n// ✅ Make all properties required\ntype RequiredUser = Required<PartialUser>;\n// { name: string; email: string; age: number }\n\n// ✅ Make all properties readonly\ntype ReadonlyUser = Readonly<User>;\n// { readonly name: string; readonly email: string; ... }\n\n// ✅ Pick specific properties\ntype UserPreview = Pick<User, 'name' | 'email'>;\n// { name: string; email: string }\n\n// ✅ Omit specific properties\ntype PublicUser = Omit<User, 'age'>;\n// { name: string; email: string }\n\n// ✅ Custom mapped type\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n\ntype NullableUser = Nullable<User>;\n// { name: string | null; email: string | null; age: number | null }\n\n// ✅ Getters for all properties\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// { getName: () => string; getEmail: () => string; getAge: () => number }\n\n// ✅ Deep partial\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\n};\n\ntype Config = {\n  database: {\n    host: string;\n    port: number;\n  };\n  cache: {\n    ttl: number;\n  };\n};\n\ntype PartialConfig = DeepPartial<Config>;\n// { database?: { host?: string; port?: number }; cache?: { ttl?: number } }\n\n// ✅ Filter properties by type\ntype PropertiesOfType<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K];\n};\n\ntype StringKeys = PropertiesOfType<User, string>;\n// { name: string; email: string }\n\n// ✅ Mutable (remove readonly)\ntype Mutable<T> = {\n  -readonly [K in keyof T]: T[K];\n};\n\ntype MutableUser = Mutable<ReadonlyUser>;\n// { name: string; email: string; age: number }\n```\n\nMapped type benefits:\n1. Transform object shapes\n2. DRY principle\n3. Type-safe transformations\n4. Composable"}]}
{"messages":[{"role":"user","content":"Demonstrate TypeScript using conditional types for type logic"},{"role":"assistant","content":"Conditional types for type-level programming:\n\n```typescript\n// ✅ Basic conditional type\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;  // true\ntype B = IsString<number>;  // false\n\n// ✅ Extract array element type\ntype ElementType<T> = T extends (infer U)[] ? U : T;\n\ntype Item = ElementType<string[]>;  // string\ntype Single = ElementType<number>;  // number\n\n// ✅ Unwrap Promise\ntype Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;\n\ntype Result = Awaited<Promise<string>>;  // string\ntype Nested = Awaited<Promise<Promise<number>>>;  // number\n\n// ✅ Function return type extraction\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction getUser() {\n  return { name: 'Alice', age: 30 };\n}\n\ntype User = ReturnType<typeof getUser>;\n// { name: string; age: number }\n\n// ✅ Exclude from union\ntype Exclude<T, U> = T extends U ? never : T;\n\ntype T1 = Exclude<'a' | 'b' | 'c', 'a'>;  // 'b' | 'c'\ntype T2 = Exclude<string | number, string>;  // number\n\n// ✅ Extract from union\ntype Extract<T, U> = T extends U ? T : never;\n\ntype T3 = Extract<'a' | 'b' | 'c', 'a' | 'f'>;  // 'a'\n\n// ✅ Non-nullable\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype T4 = NonNullable<string | null | undefined>;  // string\n\n// ✅ Flatten nested types\ntype Flatten<T> = T extends Array<infer U>\n  ? Flatten<U>\n  : T extends object\n  ? { [K in keyof T]: Flatten<T[K]> }\n  : T;\n\ntype Nested = Flatten<{ a: number[][]; b: string }>;\n// { a: number; b: string }\n\n// ✅ Distributive conditional types\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype Arrays = ToArray<string | number>;\n// string[] | number[] (distributes over union)\n\n// ✅ Non-distributive with tuple\ntype ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\n\ntype Array = ToArrayNonDist<string | number>;\n// (string | number)[] (doesn't distribute)\n```\n\nConditional type benefits:\n1. Type-level logic\n2. Infer types from structure\n3. Transform unions\n4. Extract nested types"}]}
{"messages":[{"role":"user","content":"Show TypeScript using assertion functions for type narrowing"},{"role":"assistant","content":"Assertion functions for runtime type guards:\n\n```typescript\n// ✅ Assertion function with asserts keyword\nfunction assertIsString(value: unknown): asserts value is string {\n  if (typeof value !== 'string') {\n    throw new Error('Value is not a string');\n  }\n}\n\nfunction process(value: unknown) {\n  assertIsString(value);\n  // value is narrowed to string\n  console.log(value.toUpperCase());\n}\n\n// ✅ Assert non-null\nfunction assertDefined<T>(value: T | null | undefined): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error('Value is null or undefined');\n  }\n}\n\nfunction getUser(id: string): User | null {\n  return findUser(id);\n}\n\nconst user = getUser('123');\nassertDefined(user);\nconsole.log(user.name);  // ✅ user is User, not User | null\n\n// ✅ Assert type predicate\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction assertIsString(value: unknown): asserts value is string {\n  if (!isString(value)) {\n    throw new Error('Not a string');\n  }\n}\n\n// ✅ Assert object shape\ninterface User {\n  name: string;\n  email: string;\n}\n\nfunction assertIsUser(value: unknown): asserts value is User {\n  if (\n    typeof value !== 'object' ||\n    value === null ||\n    !('name' in value) ||\n    !('email' in value)\n  ) {\n    throw new Error('Invalid user object');\n  }\n}\n\nconst data: unknown = JSON.parse(jsonString);\nassertIsUser(data);\nconsole.log(data.name);  // ✅ data is User\n\n// ✅ Assert condition\nfunction assert(condition: boolean, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message ?? 'Assertion failed');\n  }\n}\n\nfunction divide(a: number, b: number): number {\n  assert(b !== 0, 'Division by zero');\n  return a / b;\n}\n\n// ✅ Assert array elements\nfunction assertAllStrings(arr: unknown[]): asserts arr is string[] {\n  if (!arr.every(item => typeof item === 'string')) {\n    throw new Error('Not all elements are strings');\n  }\n}\n\nconst data: unknown[] = JSON.parse('[\"a\", \"b\"]');\nassertAllStrings(data);\ndata.forEach(s => console.log(s.toUpperCase()));  // ✅ s is string\n```\n\nAssertion function benefits:\n1. Type narrowing with runtime checks\n2. Throws on validation failure\n3. Cleaner than type guards\n4. Great for validation"}]}
{"messages":[{"role":"user","content":"Write TypeScript using readonly arrays and tuples"},{"role":"assistant","content":"Readonly arrays and tuples for immutability:\n\n```typescript\n// ✅ Readonly array\nfunction sum(numbers: readonly number[]): number {\n  // numbers.push(5);  // ❌ Error: push doesn't exist on readonly\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\nsum([1, 2, 3]);  // ✅ Works with regular arrays\n\n// ✅ ReadonlyArray type\nconst numbers: ReadonlyArray<number> = [1, 2, 3];\n// numbers[0] = 10;  // ❌ Error: readonly\n// numbers.push(4);  // ❌ Error: method doesn't exist\n\n// ✅ Readonly tuple\ntype Point = readonly [number, number];\n\nconst point: Point = [10, 20];\n// point[0] = 5;  // ❌ Error: readonly\n\nfunction distance(p1: Point, p2: Point): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n// ✅ Const assertion for readonly\nconst colors = ['red', 'green', 'blue'] as const;\n// Type: readonly [\"red\", \"green\", \"blue\"]\n\ntype Color = typeof colors[number];\n// Type: \"red\" | \"green\" | \"blue\"\n\n// ✅ Function parameters readonly by default\nfunction first<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n\n// ✅ Readonly in interfaces\ninterface Config {\n  readonly values: readonly string[];\n}\n\nconst config: Config = {\n  values: ['a', 'b', 'c'],\n};\n\n// config.values.push('d');  // ❌ Error\n// config.values = [];       // ❌ Error\n\n// ✅ Deep readonly\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n};\n\ninterface User {\n  name: string;\n  tags: string[];\n}\n\ntype ReadonlyUser = DeepReadonly<User>;\n// { readonly name: string; readonly tags: readonly string[] }\n\n// ✅ Readonly parameters prevent mutations\nfunction sortCopy(arr: readonly number[]): number[] {\n  return [...arr].sort((a, b) => a - b);  // Copy before mutating\n}\n```\n\nReadonly benefits:\n1. Immutability guarantees\n2. Prevent accidental mutations\n3. Safer function parameters\n4. Clear intent"}]}
{"messages":[{"role":"user","content":"Show Python using dataclasses for structured data"},{"role":"assistant","content":"Dataclasses for clean data structures:\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import List\n\n# ❌ Manual class with boilerplate\nclass User:\n    def __init__(self, name: str, age: int, email: str):\n        self.name = name\n        self.age = age\n        self.email = email\n    \n    def __repr__(self):\n        return f\"User(name={self.name}, age={self.age}, email={self.email})\"\n    \n    def __eq__(self, other):\n        if not isinstance(other, User):\n            return False\n        return self.name == other.name and self.age == other.age\n\n# ✅ Use dataclass\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\nuser = User(\"Alice\", 30, \"alice@example.com\")\nprint(user)  # User(name='Alice', age=30, email='alice@example.com')\n\n# ✅ Default values\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n\nconfig = Config()  # Uses defaults\nconfig2 = Config(port=9000)  # Override specific field\n\n# ✅ Mutable default with field()\n@dataclass\nclass Team:\n    name: str\n    members: List[str] = field(default_factory=list)  # ✅ Correct\n    # members: List[str] = []  # ❌ Would be shared across instances!\n\n# ✅ Frozen (immutable)\n@dataclass(frozen=True)\nclass Point:\n    x: float\n    y: float\n\npoint = Point(10, 20)\n# point.x = 5  # ❌ Error: frozen\n\n# ✅ Order comparison\n@dataclass(order=True)\nclass Person:\n    name: str\n    age: int\n\npeople = [Person(\"Bob\", 25), Person(\"Alice\", 30)]\npeople.sort()  # Sorts by fields in order\n\n# ✅ Post-init processing\n@dataclass\nclass Rectangle:\n    width: float\n    height: float\n    area: float = field(init=False)  # Computed, not in __init__\n    \n    def __post_init__(self):\n        self.area = self.width * self.height\n\nrect = Rectangle(10, 20)\nprint(rect.area)  # 200.0\n\n# ✅ Exclude from repr/comparison\n@dataclass\nclass CachedData:\n    value: int\n    _cache: dict = field(default_factory=dict, repr=False, compare=False)\n```\n\nDataclass benefits:\n1. Less boilerplate\n2. Auto-generated methods\n3. Type annotations required\n4. Mutable or frozen"}]}
{"messages":[{"role":"user","content":"Demonstrate Python using pathlib instead of os.path"},{"role":"assistant","content":"pathlib for modern path handling:\n\n```python\nimport os\nfrom pathlib import Path\n\n# ❌ Old way with os.path\ndata_dir = os.path.join(os.getcwd(), 'data')\nfile_path = os.path.join(data_dir, 'file.txt')\n\nif os.path.exists(file_path):\n    with open(file_path) as f:\n        contents = f.read()\n\n# ✅ Modern way with pathlib\ndata_dir = Path.cwd() / 'data'\nfile_path = data_dir / 'file.txt'\n\nif file_path.exists():\n    contents = file_path.read_text()\n\n# ✅ Read/write files directly\nconfig_path = Path('config.json')\nconfig = config_path.read_text()  # Read entire file\nconfig_path.write_text(json.dumps(data))  # Write file\n\nbinary_path = Path('data.bin')\ndata = binary_path.read_bytes()  # Read binary\nbinary_path.write_bytes(b'\\x00\\x01')  # Write binary\n\n# ✅ Path manipulation\npath = Path('/home/user/projects/myapp/src/main.py')\n\nprint(path.name)        # main.py\nprint(path.stem)        # main\nprint(path.suffix)      # .py\nprint(path.parent)      # /home/user/projects/myapp/src\nprint(path.parents[1])  # /home/user/projects/myapp\nprint(path.parts)       # ('/', 'home', 'user', ...)\n\n# ✅ Glob patterns\nfor py_file in Path('src').glob('**/*.py'):\n    print(py_file)\n\nfor txt_file in Path('.').rglob('*.txt'):\n    print(txt_file)  # Recursive\n\n# ✅ Create directories\ndata_dir = Path('data/cache/temp')\ndata_dir.mkdir(parents=True, exist_ok=True)\n\n# ✅ Check file types\npath = Path('file.txt')\nif path.is_file():\n    print('Is a file')\nif path.is_dir():\n    print('Is a directory')\nif path.is_symlink():\n    print('Is a symlink')\n\n# ✅ Resolve paths\npath = Path('src/../data/./file.txt')\nresolved = path.resolve()  # /absolute/path/to/data/file.txt\n\n# ✅ Home directory\nhome = Path.home()  # /home/user\nconfig = home / '.config' / 'myapp' / 'config.ini'\n\n# ✅ Change suffix\npy_file = Path('script.py')\ntxt_file = py_file.with_suffix('.txt')  # script.txt\n```\n\npathlib benefits:\n1. Object-oriented API\n2. Path operations with /\n3. Built-in read/write\n4. Cleaner than os.path"}]}
{"messages":[{"role":"user","content":"Show Python using walrus operator for assignment expressions"},{"role":"assistant","content":"Walrus operator for inline assignment:\n\n```python\n# ❌ Without walrus operator\ndata = get_data()\nif data:\n    process(data)\n\n# ✅ With walrus operator\nif data := get_data():\n    process(data)\n\n# ✅ While loops\n# ❌ Verbose\nline = file.readline()\nwhile line:\n    process(line)\n    line = file.readline()\n\n# ✅ Concise\nwhile line := file.readline():\n    process(line)\n\n# ✅ List comprehensions with condition\n# ❌ Computes expensive_fn twice\nresults = [expensive_fn(x) for x in items if expensive_fn(x) > 0]\n\n# ✅ Computes once\nresults = [y for x in items if (y := expensive_fn(x)) > 0]\n\n# ✅ Regex matching\nimport re\n\n# ❌ Without walrus\nmatch = re.search(r'\\d+', text)\nif match:\n    number = match.group()\n    process(number)\n\n# ✅ With walrus\nif match := re.search(r'\\d+', text):\n    process(match.group())\n\n# ✅ Multiple conditions\n# Check and use in one expression\nif (n := len(items)) > 10:\n    print(f\"Too many items: {n}\")\nelif n > 5:\n    print(f\"Some items: {n}\")\n\n# ✅ Reuse computed value\ndata = [1, 2, 3, 4, 5]\nif (total := sum(data)) > 10:\n    average = total / len(data)\n    print(f\"Average: {average}\")\n\n# ⚠️ Don't overuse - can hurt readability\n# ❌ Too complex\nif (x := get_x()) and (y := compute(x)) and (z := validate(y)):\n    process(z)\n\n# ✅ Better: be explicit\nx = get_x()\nif x:\n    y = compute(x)\n    if y:\n        z = validate(y)\n        if z:\n            process(z)\n```\n\nWalrus operator benefits:\n1. Avoid duplicate computation\n2. More concise code\n3. Useful in comprehensions\n4. Don't overuse - readability matters"}]}
{"messages":[{"role":"user","content":"Write Python using match statement for pattern matching"},{"role":"assistant","content":"Match statement for structural pattern matching:\n\n```python\n# ✅ Basic match with literals\ndef http_status(status: int) -> str:\n    match status:\n        case 200:\n            return \"OK\"\n        case 404:\n            return \"Not Found\"\n        case 500:\n            return \"Internal Server Error\"\n        case _:\n            return \"Unknown\"\n\n# ✅ Match with OR patterns\nmatch status:\n    case 200 | 201 | 204:\n        return \"Success\"\n    case 400 | 404:\n        return \"Client Error\"\n    case _:\n        return \"Other\"\n\n# ✅ Destructure sequences\npoint = (10, 20)\n\nmatch point:\n    case (0, 0):\n        print(\"Origin\")\n    case (0, y):\n        print(f\"On Y axis at {y}\")\n    case (x, 0):\n        print(f\"On X axis at {x}\")\n    case (x, y):\n        print(f\"Point at ({x}, {y})\")\n\n# ✅ Match with guards\nmatch point:\n    case (x, y) if x == y:\n        print(\"On diagonal\")\n    case (x, y) if x > y:\n        print(\"Above diagonal\")\n    case _:\n        print(\"Below diagonal\")\n\n# ✅ Match class instances\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\nmatch point:\n    case Point(x=0, y=0):\n        print(\"Origin\")\n    case Point(x=0, y=y):\n        print(f\"Y axis: {y}\")\n    case Point(x=x, y=y):\n        print(f\"Point: ({x}, {y})\")\n\n# ✅ Match dictionaries\nuser = {\"name\": \"Alice\", \"age\": 30, \"role\": \"admin\"}\n\nmatch user:\n    case {\"role\": \"admin\", \"name\": name}:\n        print(f\"Admin: {name}\")\n    case {\"role\": \"user\", \"name\": name}:\n        print(f\"User: {name}\")\n    case _:\n        print(\"Unknown role\")\n\n# ✅ Match with as patterns\nmatch data:\n    case [x, y] as point:\n        # Bind entire value to 'point'\n        print(f\"Point: {point}\")\n\n# ✅ Complex nested patterns\nmatch command:\n    case [\"move\", (x, y)]:\n        move_to(x, y)\n    case [\"draw\", (x1, y1), (x2, y2)]:\n        draw_line(x1, y1, x2, y2)\n    case [\"circle\", (x, y), radius]:\n        draw_circle(x, y, radius)\n```\n\nMatch statement benefits:\n1. Structural pattern matching\n2. Destructuring\n3. Guards for conditions\n4. More readable than if/elif"}]}
